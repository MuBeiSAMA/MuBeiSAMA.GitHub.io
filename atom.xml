<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MuBeiSAMA&#39;s blog</title>
  <icon>https://mubeisama.github.io/icon.png</icon>
  
  <link href="https://mubeisama.github.io/atom.xml" rel="self"/>
  
  <link href="https://mubeisama.github.io/"/>
  <updated>2023-03-18T12:26:26.745Z</updated>
  <id>https://mubeisama.github.io/</id>
  
  <author>
    <name>朷北</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 基础</title>
    <link href="https://mubeisama.github.io/2022/08/20/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <id>https://mubeisama.github.io/2022/08/20/JavaScript%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-20T06:23:27.766Z</published>
    <updated>2023-03-18T12:26:26.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><p>什么是作用域？</p><blockquote><p>通常来说一段程序代码中使用的变量和函数并不总是可用的，限定其可用性的范围即作用域。</p></blockquote><p>通俗来说，作用域就是函数和变量起作用的区域。</p><p>js 存在三种作用域：</p><a id="more"></a><ul><li>全局作用域。声明在函数和代码块之外的变量（在全局的任意地方都可以调用或修改），和在 window 下的属性。</li><li>函数作用域（局部作用域）。声明在函数内部的变量，只能在函数内部使用。</li><li>块级作用域。ES6 引入的概念。块级作用域通过花括号（<code>&#123;&#125;</code>）创建，会将 <code>let</code> 和 <code>count</code> 声明的变量作用域限制在当前代码块中。<code>var</code> 的声明提前会无视块级作用域。</li></ul><p>作用域是分层的，子作用域可以沿着链式的<code>作用域链</code>访问父作用域的变量，反之则不行。</p><p>那么什么是闭包呢？</p><p>当函数（子作用域）存在对父作用域的引用时，为了保证函数的正常执行，这时即使父作用域执行结束关闭了，但引用的变量依然会被保留，不被回收释放，这种特殊的机制就是闭包。</p><p>闭包的一个实用作用是创建私有变量和方法。</p><p>一个例子是累加器，非闭包的话变量会被全局访问到，被重新定义或修改的话就累加功能就被破坏了，通过闭包就可以规避这个问题。</p><p>另一个例子是存储，可以通过闭包实现类似 <code>vuex</code> 的能力。提供特定的方法来增删改查在闭包中的引用值。</p><p>闭包的一个经典问题是：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#creating_closures_in_loops_a_common_mistake">在循环中创建闭包：一个常见错误</a>。</p><p>原因是执行上下文在运行时才确定。</p><h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><blockquote><p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为 <code>__proto__</code> ）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（<code>__proto__</code>），层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p></blockquote><p>为了理解这段话，我们先看看继承是怎么产生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">const</span> rename = name.replace(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(rename)</span><br><span class="line"><span class="comment">// output: 李四</span></span><br></pre></td></tr></table></figure><p>上面是这段代码声明了一个 <code>name</code> 常量，并调用 <code>replace()</code>。这时问题就来了，<code>replace()</code> 咋来的呢？</p><p>JavaScript 是一种基于原型的语言，这段代码在执行时，<code>name</code> 实际上是 <code>String</code> 的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;张三&#x27;</span>) <span class="comment">// String &#123;&#x27;张三&#x27;&#125;</span></span><br><span class="line"><span class="keyword">const</span> rename = name.replace(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(rename)</span><br><span class="line"><span class="comment">// output: 李四</span></span><br></pre></td></tr></table></figure><!-- `name` 实际上是 `String` 这个全局构造函数创建的实例。 --><p>作为 <code>String</code> 的实例，<code>name</code> 并不是一个单纯的字符串，而是一个对象。<code>name</code> 的隐式属性 <code>__proto__</code> 指向 <code>String</code> 的原型。当访问 <code>name</code> 的属性和方法时，会按照原型链依次向上寻找，直至访问到 <code>null</code> 为止。而调用 <code>replace()</code> 就是通过对 <code>String</code> 的继承形成的原型链，访问到了存在于 <code>String</code> 的原型的方法。</p><p><code>String</code> 的原型也有自己的 <code>__proto__</code>，指向 <code>Object</code> 的原型。于是，基于这样的继承关系，完整的原型链如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name -&gt; <span class="built_in">String</span>.prototype -&gt; <span class="built_in">Object</span>.prototype -&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>同理，其他几种数据类型也一样，都是由对应的构造函数创建的实例，所以才说 JavaScript 万物皆对象。</p><p>构造函数和原型的关系是：构造函数的 <code>prototype</code> 属性指向原型对象，这个对象包含所有实例共享的方法和属性。原型对象的 <code>constructor</code> 指向构造函数本身。</p><p><img src="https://s2.loli.net/2022/08/25/C5LiXjMGpzcWw9k.png" alt="图源：掘金"></p><p>构造函数和正常函数没有本质的区别，一个使用 function 正常声明的函数，用 new 操作符调用，就是构造函数。我们也可以自己创建构造函数来实现继承，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.body = <span class="number">1</span></span><br><span class="line">Person.prototype.eye = <span class="number">2</span></span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Ate:&#x27;</span>, food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LiHua = <span class="keyword">new</span> Person(<span class="string">&#x27;男&#x27;</span>) <span class="comment">// Person &#123;gender: &#x27;男&#x27;&#125;</span></span><br><span class="line">LiHua.eat(<span class="string">&#x27;apple&#x27;</span>) <span class="comment">// Ate: apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * LiHua 的继承链如下：</span></span><br><span class="line"><span class="comment"> * LiHua -&gt; Person.prototype -&gt; Function.prototype -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>箭头函数没有原型</strong>，也就没有对应的构造函数，所以无法使用 new 操作符。</p><p><code>new</code> 关键字会进行如下的操作：</p><ol><li>创建一个空的简单 JavaScript 对象，即<code>&#123;&#125;</code>；</li><li>为步骤 1 新创建的对象添加属性<code>__proto__</code>，将该属性链接至构造函数的原型对象；</li><li>将步骤 1 新创建的对象作为 <code>this</code> 的上下文；</li><li>如果该函数没有返回对象，则返回 <code>this</code>。</li></ol><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h2 id="事情循环机制（event-loop）"><a href="#事情循环机制（event-loop）" class="headerlink" title="事情循环机制（event loop）"></a>事情循环机制（event loop）</h2><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h2 id="JavaScript-解释器"><a href="#JavaScript-解释器" class="headerlink" title="JavaScript 解释器"></a>JavaScript 解释器</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;作用域和闭包&quot;&gt;&lt;a href=&quot;#作用域和闭包&quot; class=&quot;headerlink&quot; title=&quot;作用域和闭包&quot;&gt;&lt;/a&gt;作用域和闭包&lt;/h2&gt;&lt;p&gt;什么是作用域？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常来说一段程序代码中使用的变量和函数并不总是可用的，限定其可用性的范围即作用域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗来说，作用域就是函数和变量起作用的区域。&lt;/p&gt;
&lt;p&gt;js 存在三种作用域：&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识体系" scheme="https://mubeisama.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="前端知识体系" scheme="https://mubeisama.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="复习" scheme="https://mubeisama.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="JavaScript" scheme="https://mubeisama.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 基础</title>
    <link href="https://mubeisama.github.io/2022/08/02/CSS%E5%9F%BA%E7%A1%80/"/>
    <id>https://mubeisama.github.io/2022/08/02/CSS%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-02T06:12:56.291Z</published>
    <updated>2023-03-16T06:37:40.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class-命名规范"><a href="#Class-命名规范" class="headerlink" title="Class 命名规范"></a>Class 命名规范</h2><p>在之前，我们一般遵循 <code>BEM</code> 规范，BEM 即块（block）、元素（element）、修饰符（modifier）。</p><p>它的规则是：</p><a id="more"></a><ul><li>块名称为其元素和修饰符定义了命名空间。</li><li>块名称与元素名称之间用双连字符–分隔。</li><li>块名称与修饰符或元素与修饰符之间用双下划线__分隔。</li><li>命名一般使用小写字母。</li><li>单词之间可以使用-分隔。</li></ul><p>命名约定的模式有如下几种：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.block__element</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.block--modifier</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.block__element--modifier</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这种规范的好处是：</p><ol><li>将界面分块，便于管理，方便复用。</li><li>通过精确具体的类名，避免类名污染，防止全局覆盖问题。</li></ol><p>在今天，随着 css 框架的流行，更简洁易用的<a href="https://less.bootcss.com/#%E5%B5%8C%E5%A5%97nesting">嵌套写法</a>逐渐成为主流，遵循顾名思义原则即可。<code>BEM</code> 精确具体的类名要求也导致写起来冗长繁琐，且嵌套写法也不存在类名污染问题，<code>BEM</code>也就慢慢淡出日常开发了。</p><p>组件库之类全局样式多的领域 <code>BEM</code> 这种命名思想还在发光发热，但基本简化为仅以连字符分割（<code>block-element-modifier</code> ）的形式了。</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>什么是盒模型？</p><p>浏览器的渲染引擎会根据标准之一的 <code>CSS 基础框盒模型（CSS basic box model）</code>，将所有元素表示为一个个矩形的盒子。</p><p>每个盒子由四个部分：内容（content）、内边距（padding）、边框（border）和外边距（margin）。</p><p>盒模型的定义由 <code>box-sizing</code> 属性控制，<code>box-sizing</code> 有两个可用的值：</p><ol><li><code>content-box</code>，W3C标准盒模型，默认值。设置元素的宽高只作用于<code>内容（content）</code>。</li><li><code>border-box</code>，IE盒模型，设置元素的宽高包含<code>内容（content）</code>、<code>内边距（padding）</code>和<code>边框（border）</code>。大多数情况下，这使得我们更容易地设定一个元素的宽高。</li></ol><h2 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h2><p>块的上外边距 (margin-top)和下外边距 (margin-bottom)有时合并 (折叠) 为单个边距，其大小为单个边距的最大值，这种行为称为边距折叠。</p><blockquote><p>注意有设定 float 和 position=absolute 的元素不会产生外边距重叠行为。</p></blockquote><p>有三种情况会形成外边距重叠：</p><ol><li>同一层相邻元素之间</li><li>没有内容将父元素和后代元素分开</li><li>空的块级元素</li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><code>BFC</code> 是什么？</p><p>MDN 的解释是：</p><blockquote><p>块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p></blockquote><p>听起来很拗口，实际上解释 <code>BFC</code> 的文章也非常多，但众说纷纷，看完也很难理解。</p><p>其实 <code>BFC</code> 这个概念并不重要，我们先跳过 <code>BFC</code> 是什么这个问题，来看 <code>BFC</code> 的特性。</p><p>MDN 对 <code>BFC</code> 特性的描述有三点：</p><ul><li>包含内部浮动</li><li>排除外部浮动</li><li>阻止外边距重叠</li></ul><p>用一句话总结就是：<strong>内部子元素不会影响外部元素</strong>。记住这句话之后，再来逐个理解。</p><h3 id="包含内部浮动"><a href="#包含内部浮动" class="headerlink" title="包含内部浮动"></a>包含内部浮动</h3><p>默认情况下，内部元素浮动，就会溢出，如下图。</p><p><img src="https://s2.loli.net/2022/08/04/yji59Rza8kQfh6d.png" alt="image.png"></p><p>但当父元素为 BFC 时，父元素就会包含子元素的浮动，也就不会溢出造成对外部元素的影响。</p><h3 id="排除外部浮动"><a href="#排除外部浮动" class="headerlink" title="排除外部浮动"></a>排除外部浮动</h3><p>左侧盒子浮动，默认情况下，由于盒子脱离文档流，正常元素会继续从盒子位置排列。</p><p><img src="https://s2.loli.net/2022/08/04/4rT1ZygxiBwKfuY.png" alt="image.png"></p><p>但当正常元素变为 <code>BFC</code> 元素时，为了和外部浮动元素不产生影响，顺着浮动边缘形成了自己的封闭上下文。</p><p>这里再放一个张鑫旭大佬的例子：</p><iframe src="https://www.zhangxinxu.com/study/201502/flow-to-bfc.html" width="100%" height="180" frameborder="0"></iframe><p>可以很清楚的看出排除外部浮动这一特性。</p><h3 id="阻止外边距重叠"><a href="#阻止外边距重叠" class="headerlink" title="阻止外边距重叠"></a>阻止外边距重叠</h3><p><img src="https://s2.loli.net/2022/08/04/YwTWyKOb4aUgz6c.png" alt="image.png"></p><p>默认情况下 .blue 和 .red-inner 会发生外边距重叠，.red-inner 的 margin 将不生效。</p><p>但 .red-outer 添加了 <code>overflow: hidden</code> 变成了 <code>BFC</code> 元素。子元素的边距重叠就被消除了，阻止了对外部元素的影响。</p><h3 id="BFC-是什么？"><a href="#BFC-是什么？" class="headerlink" title="BFC 是什么？"></a>BFC 是什么？</h3><p>理解了特性之后再回到一开始的问题，就好回答了。</p><p><strong>BFC 就是特定方式创建的特性元素</strong>。</p><p>几种常见的创建 BFC 元素的方式：</p><ul><li>根元素（<code>&lt;html&gt;</code>）</li><li>浮动元素（float 值不为 none）</li><li>绝对定位元素（position 值为 absolute 或 fixed）</li><li>行内块元素（display 值为 inline-block）</li><li>表格单元格（display 值为 table-cell，HTML 表格单元格默认值）</li><li>overflow 值不为 visible、clip 的块元素</li><li>display 值为 flow-root 的元素</li><li>弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器</li><li>网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器</li><li>多列容器（column-count 或 column-width (en-US) 值不为 auto，包括column-count 为 1）</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a><br><a href="https://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/">https://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Class-命名规范&quot;&gt;&lt;a href=&quot;#Class-命名规范&quot; class=&quot;headerlink&quot; title=&quot;Class 命名规范&quot;&gt;&lt;/a&gt;Class 命名规范&lt;/h2&gt;&lt;p&gt;在之前，我们一般遵循 &lt;code&gt;BEM&lt;/code&gt; 规范，BEM 即块（block）、元素（element）、修饰符（modifier）。&lt;/p&gt;
&lt;p&gt;它的规则是：&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识体系" scheme="https://mubeisama.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="前端知识体系" scheme="https://mubeisama.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="复习" scheme="https://mubeisama.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="CSS" scheme="https://mubeisama.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>记录一次手机 ROOT 的详细过程</title>
    <link href="https://mubeisama.github.io/2022/02/25/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%BAROOT%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/"/>
    <id>https://mubeisama.github.io/2022/02/25/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%BAROOT%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/</id>
    <published>2022-02-25T02:30:08.952Z</published>
    <updated>2022-02-28T04:07:48.351Z</updated>
    
    <content type="html"><![CDATA[<p>我手持的是小米 Redmi K20 Pro, MIUI 12.5，骁龙 855 芯片，用了两年多依旧坚挺。</p><p>ROOT 的起因是最近在玩一款单机手游，实在太肝了受不了，想开修改器和加速之类的降低一点难度。当然 ROOT 之后不仅仅是开个修改器，还有很多能力。</p><p>小米 ROOT 的方式很多，我大概举例一下：</p><a id="more"></a><ol><li><p>申请官方内测资格，最简单安全的方式。小米社区直接申请，申请成功后系统可以转为开发版，社区有详细步骤，开发版自带 ROOT 权限。缺点就是需要积分，申请内测资格需要 300 点内测分，还需要答题。我只有 100 多分，太麻烦了，放弃。</p></li><li><p><code>Magisk</code> 补 BOOT，应该是目前最主流的 ROOT 方式。不影响当前系统，稳定版一样可以获取 ROOT 权限，仅依赖 Magisk 就够了，重启也不影响，缺点是每次系统更新都需要重新补 BOOT。</p></li><li><p>刷第三方 Recovery（简称 rec）<code>橙狐</code>再补 BOOT。还是依靠 <code>Magisk</code> 补 BOOT，再通过<code>橙狐</code>刷入，<code>橙狐</code>自带 xiaomi ota，后续系统升级可以通过它来完成，ROOT 权限就能一直存在了。</p></li></ol><p>我采用的是第三种方式，看起来很多术语很复杂，实操起来几分钟就能搞定。</p><h2 id="解-BL-锁"><a href="#解-BL-锁" class="headerlink" title="解 BL 锁"></a>解 BL 锁</h2><p>这应该是目前所有手机 ROOT 的第一步了，小米可以直接访问 <a href="http://www.miui.com/unlock/index.html">官方解锁地址</a>，按步骤操作，需要手机登陆小米账号满 7 天。</p><p>需要注意<strong>解锁时数据将被清空，一定要提前备份</strong>。<code>小米换机</code>可以 100% 备份所有数据。<code>手机备份</code>打的包只有应用数据，不包含照片和主题，需要额外备份。</p><p>后面的操作解了 BL 锁才能继续，不会再清空数据了，不过以防万一还是留一份备份比较好。</p><h2 id="开始-ROOT"><a href="#开始-ROOT" class="headerlink" title="开始 ROOT"></a>开始 ROOT</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>需要用到的物料：</p><ol><li>联网的 PC 一台</li><li>数据线</li></ol><p>PC 上需要准备的软件：</p><ol><li><code>橙狐</code> 的 <code>recovery.img</code> 文件</li><li><code>Magisk</code> 的安装包</li><li>当前手机系统的 ROM 文件</li><li>【可选】搞机助手</li></ol><h4 id="从橙狐的包中提取-recovery-img"><a href="#从橙狐的包中提取-recovery-img" class="headerlink" title="从橙狐的包中提取 recovery.img"></a>从橙狐的包中提取 recovery.img</h4><p><code>橙狐</code>的包可以<a href="https://orangefox.download/zh-CN">访问官网</a>，找到自己的手机型号，点下载再点弹窗里的国家节点即可下载。</p><p><img src="https://s2.loli.net/2022/02/25/b8XI3k9wE4Ktiuz.png" alt="图 1"></p><p>下载好后解压压缩包，将里面的 <code>recovery.img</code> 文件提取到自己找得到的地方备用。</p><h4 id="Magisk的安装包"><a href="#Magisk的安装包" class="headerlink" title="Magisk的安装包"></a>Magisk的安装包</h4><p>GitHub 开源软件，访问 <a href="https://github.com/topjohnwu/Magisk/releases">Release 页面</a>下载最新版就好。</p><h4 id="当前手机系统的-ROM-包"><a href="#当前手机系统的-ROM-包" class="headerlink" title="当前手机系统的 ROM 包"></a>当前手机系统的 ROM 包</h4><p>访问 <a href="https://xiaomirom.com/">https://xiaomirom.com/</a> 搜索自己的手机型号，我是 K20 Pro，国外这款手机叫 9T Pro。</p><p><img src="https://s2.loli.net/2022/02/25/vqVUEdncetyxBNI.png" alt="图 2"></p><p>点进去找到和自己一样的 MIUI 版本的包，我的是 V12.5.6.0.RFKCNXM。</p><p><img src="https://s2.loli.net/2022/02/25/YZyK3cW2AxBGzSU.png" alt="图 3"></p><p>下载完成后解压压缩包，将里面的 <code>boot.img</code> 文件提取到自己找得到的地方备用。</p><h4 id="发送到手机"><a href="#发送到手机" class="headerlink" title="发送到手机"></a>发送到手机</h4><p>数据线连接手机，打开 USB 调试。没有 USB 调试就先在 <code>设置-&gt;我的设备-&gt;全部参数</code> 点击 <strong>MIUI 版本</strong>七八次，打开开发者模式，再搜 USB 调试就有了。</p><p>通过数据线将准备好的 <code>Magisk</code> 安装包、<code>recovery.img</code> 和 <code>boot.img</code>  传到手机存储下。</p><h3 id="Magisk-补-BOOT"><a href="#Magisk-补-BOOT" class="headerlink" title="Magisk 补 BOOT"></a>Magisk 补 BOOT</h3><p>在手机上找到发来的 <code>Magisk</code> 安装包，安装。安装好后界面如下：</p><p><img src="https://s2.loli.net/2022/02/28/N9KvGJqV6uED1eZ.jpg" alt="为了阅读体验已旋转 -90deg"></p><p>点击 <code>Magisk</code> 卡片的安装按钮，进入安装详情页。</p><p><img src="https://s2.loli.net/2022/02/28/bf6YAFjk7OiKu5g.jpg" alt="图 5">  </p><p>选项栏什么都不用选直接下一步，方式选中<strong>选择并修补一个文件</strong>，然后选择从 PC 接收的 <code>boot.img</code> 文件开始修补。</p><p>修补成功后会在 download 文件夹生成 <code>magisk_patched_xxxxxx.img</code> 文件。记住这个文件名和的位置，之后会用到。</p><h3 id="刷入橙狐"><a href="#刷入橙狐" class="headerlink" title="刷入橙狐"></a>刷入橙狐</h3><p>保持 PC 和手机的数据线连接，手机关机后开机键+音量下键，进入 fastboot 模式。</p><p>如果电脑上准备好了搞机助手，就在<code>引导模式-&gt;刷入 REC-&gt;选择 Recovery</code>选中准备好的<code>橙狐</code> 的 <code>recovery.img</code> 文件，点击刷入。</p><p>没有搞机助手的话，可以参考<a href="https://wiki.orangefox.tech/en/guides/installing_orangefox#via-fastboot-and-then-recovery">橙狐官方 wiki</a>，电脑安装 adb，命令行直接输入命令手动刷入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure><p>刷入后手机会自动进入 <code>橙狐</code> rec，没有自动进入的话也可以在关机后按开机键+音量上键进入。</p><blockquote><p>橙狐的recovery有解密功能启动可能较慢 启动后输入锁屏密码 等待解密 否则无法加载sdcard</p></blockquote><p>输入锁屏密码成功后, <code>橙狐</code> 的首页就是一个文件管理器，找到从 PC 接收的 <code>recovery.img</code>，选中，目标分区选 Recovery。</p><p><img src="https://s2.loli.net/2022/02/28/inKH2lfmQcsoYvP.jpg" alt="图源：Bilibili@LACIAN">  </p><p>成功后先不重启，继续找到之前 <code>Magisk</code> 补好的 <code>magisk_patched_xxxxxx.img</code> 文件，刷入到 Boot 分区，完成后重启。</p><p>开机后就有 ROOT 权限了。</p><p><img src="https://s2.loli.net/2022/02/28/La4DPh27NnQYkiV.jpg" alt="图 8"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><del>之前说 ROOT 后不仅仅是开个修改器。</del></p><p>Magisk 更新导致 zygisk 和 Riru 不兼容，Lsposed 也没法用了。听说有个 zygisk-lsposed 的兼容版，github 也没找到，更新之后再补充。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/read/cv13745586">https://www.bilibili.com/read/cv13745586</a><br><a href="https://github.com/LSPosed/LSPosed">https://github.com/LSPosed/LSPosed</a><br><a href="https://github.com/topjohnwu/Magisk">https://github.com/topjohnwu/Magisk</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我手持的是小米 Redmi K20 Pro, MIUI 12.5，骁龙 855 芯片，用了两年多依旧坚挺。&lt;/p&gt;
&lt;p&gt;ROOT 的起因是最近在玩一款单机手游，实在太肝了受不了，想开修改器和加速之类的降低一点难度。当然 ROOT 之后不仅仅是开个修改器，还有很多能力。&lt;/p&gt;
&lt;p&gt;小米 ROOT 的方式很多，我大概举例一下：&lt;/p&gt;</summary>
    
    
    
    <category term="搞机" scheme="https://mubeisama.github.io/categories/%E6%90%9E%E6%9C%BA/"/>
    
    
    <category term="小米/MIUI" scheme="https://mubeisama.github.io/tags/%E5%B0%8F%E7%B1%B3-MIUI/"/>
    
    <category term="ROOT" scheme="https://mubeisama.github.io/tags/ROOT/"/>
    
    <category term="Magisk" scheme="https://mubeisama.github.io/tags/Magisk/"/>
    
    <category term="橙狐/OrangeFox" scheme="https://mubeisama.github.io/tags/%E6%A9%99%E7%8B%90-OrangeFox/"/>
    
    <category term="安卓/Android" scheme="https://mubeisama.github.io/tags/%E5%AE%89%E5%8D%93-Android/"/>
    
  </entry>
  
  <entry>
    <title>gitlab npm package 初体验</title>
    <link href="https://mubeisama.github.io/2021/11/12/gitlab%20npm%20package%20%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://mubeisama.github.io/2021/11/12/gitlab%20npm%20package%20%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-11-12T08:24:38.341Z</published>
    <updated>2022-06-22T07:59:26.046Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间公司私有化部署的 gitlab 更新了下，发现 gitlab 支持 npm 的包管理了。</p><p>随即打算把私服 nexus 上的 npm 包迁移一下，于是有了这篇文章。</p><p>这篇文章会以 gitlab 官网为示例逐步介绍如何在 gitlab 中发布和使用自己的 npm 包。</p><p>除 npm 以外，gitlab 还支持大多数常见的包管理器，如 Go、Maven、Ruby Gems 等。</p><a id="more"></a><p><strong>前提条件：</strong></p><ul><li>node &amp; npm/yarn</li><li>gitlab 账号</li></ul><h2 id="gitlab-npm-包注册表"><a href="#gitlab-npm-包注册表" class="headerlink" title="gitlab npm 包注册表"></a>gitlab npm 包注册表</h2><p>gitlab 要求注册的包必须是 <a href="https://docs.npmjs.com/cli/v7/using-npm/scope/">scope packages</a>，即包名称的格式必须是 <code>@scope/package-name</code>。</p><p>gitlab 提供两个选项来作为包的端点，项目级和实例级：</p><ul><li><strong>项目级</strong>：当你有很少的 npm 包并且它们不在同一个 GitLab 组中时使用。该软件包的命名约定没有在这个级别执行。相反，您应该为您的包使用范围。使用范围时，注册表 URL仅针对该范围更新。<br>在项目级别注册包时，您可以使用/附加您自己的唯一范围到您的包名称。<br>如果需要，可以公开在项目级别注册的包。</li><li><strong>实例级</strong>：当您在不同的 GitLab 组或它们自己的命名空间中有许多 npm 包时使用。请务必遵守包命名约定。</li></ul><p>这是谷歌翻译的原文，不太好理解，后面会解释两种端点的差异。</p><p>这块详情可见<a href="https://docs.gitlab.com/ee/user/packages/npm_registry/#use-the-gitlab-endpoint-for-npm-packages">官方文档</a>。</p><h2 id="gitlab-设置"><a href="#gitlab-设置" class="headerlink" title="gitlab 设置"></a>gitlab 设置</h2><p>先在 gitlab 中创建一个空白仓库 <code>hex2rgb</code> 作为我们待会项目提交的仓库。</p><p><img src="https://i.loli.net/2021/11/05/K7MztLoR3e6acSq.png" alt="图 1">  </p><p><img src="https://i.loli.net/2021/11/05/TDnLeW8ihaZNozy.png" alt="图 2">  </p><p>创建好后记录一下存储库的 git URL 和 project ID, 后面会用到它们。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>接下来写一个简单的 commonJS 模块作为待会要发布的 npm 包。</p><p>创建并进入文件夹。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir hex2rgb &amp;&amp; <span class="built_in">cd</span> hex2rgb</span><br></pre></td></tr></table></figure><p>项目初始化，包名称需要注意使用 scope 包模式（<code>@username/projectname</code>），scope 为自己的用户名，其他默认。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn init v1.22.4</span></span><br><span class="line"><span class="comment"># question name (hex2rgb): @mubeisama/hex2rgb</span></span><br></pre></td></tr></table></figure><p>初始化的 package.json 内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;@mubeisama/hex2rgb&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加 <code>/index.js</code> 文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>hex example: #000000</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex2rgb</span>(<span class="params">hex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="regexp">/^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i</span>.exec(hex)</span><br><span class="line">  <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> [, r, g, b] = result</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`rbg(<span class="subst">$&#123;<span class="built_in">parseInt</span>(r, <span class="number">16</span>)&#125;</span>, <span class="subst">$&#123;<span class="built_in">parseInt</span>(g, <span class="number">16</span>)&#125;</span>, <span class="subst">$&#123;<span class="built_in">parseInt</span>(b, <span class="number">16</span>)&#125;</span>)`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = hex2rgb</span><br></pre></td></tr></table></figure><p>写好了，准备发布。</p><h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><p>gitlab 提供两种发布方法：</p><ul><li>命令行，<code>npm publish</code> 或 <code>yarn publish</code>，这种方式需要手动添加个人的 gitlab <code>Access Token</code> 到配置中</li><li>CI/CD，触发后自动发布，不需要手动配置 <code>Access Token</code></li></ul><h3 id="CI-CD-方式"><a href="#CI-CD-方式" class="headerlink" title="CI/CD 方式"></a>CI/CD 方式</h3><p>添加 <code>/.npmrc</code> 文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set URL for your scope packages.</span></span><br><span class="line"><span class="comment"># @&lt;your_scope&gt;:registry=https://gitlab.com/api/v4/npm/</span></span><br><span class="line">@mubeisama:registry=https://gitlab.com/api/v4/npm/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the token for the scope packages URL. This will allow you to download</span></span><br><span class="line">//gitlab.com/api/v4/packages/npm/:_authToken=<span class="variable">$&#123;CI_JOB_TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add token for uploading to the registry. Replace &lt;your_project_id&gt;</span></span><br><span class="line"><span class="comment"># //gitlab.com/api/v4/projects/&lt;your_project_id&gt;/packages/npm/:_authToken=$&#123;CI_JOB_TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line">//gitlab.com/api/v4/projects/31255575/packages/npm/:_authToken=<span class="variable">$&#123;CI_JOB_TOKEN&#125;</span></span><br></pre></td></tr></table></figure><p>内容为鉴权配置，注意替换 scope 名称 和 project_id。</p><p>此处的 <code>CI_JOB_TOKEN</code> 是 CI/CD 的默认环境变量，可以代替个人 Token。</p><p>再添加 <code>/.gitlab-ci.yml</code> 文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">node:14.18.1-slim</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">publish</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>更新 <code>package.json</code>，增加 publishConfig。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;@mubeisama/hex2rgb&quot;</span>,</span><br><span class="line">  ...</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    <span class="comment">// 替换为自己的 scope</span></span><br><span class="line">    &quot;@mubeisama:registry&quot;: &quot;https://gitlab.com/api/v4/projects/31255575/packages/npm/&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成。接下来提交到 main 分支就会触发 CI/CD 了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换为自己的仓库地址</span></span><br><span class="line">git init --initial-branch=main</span><br><span class="line">git remote add origin https://gitlab.com/MuBeiSAMA/hex2rgb.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>如果 <code>git init --initial-branch=main</code> 报错的话，升级 <code>git</code> 到最新版即可解决。</p><p>配置没错的话，CI/CD 的 pipeline 里会有条记录。</p><p><img src="https://i.loli.net/2021/11/12/4iHXDJNepsWnzdj.png" alt="图 1">  </p><p>跑完后包注册表里就能看到打好的包了。</p><p><img src="https://i.loli.net/2021/11/12/jeZWIqOyT1fihEG.png" alt="图 2">  </p><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>在 gitlab 首页点右上角的头像，展开的菜单里点 preferences 进入偏好设置。</p><p>在 Access Tokens 面板创建 Token，权限按需勾选，创建好后的 Token 只会在顶部出现一次，记录下来。</p><p><img src="https://i.loli.net/2021/11/12/eBFOsavKmCpQXul.png" alt="图 3">  </p><p>回到项目里，修改 <code>.npmrc</code>，将 CI_JOB_TOKEN 替换为自己的 Token：</p><figure class="highlight sh"><figcaption><span>.npmrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mubeisama:registry=https://gitlab.com/api/v4/npm/</span><br><span class="line"></span><br><span class="line">//gitlab.com/api/v4/packages/npm/:_authToken=&lt;your_token&gt;</span><br><span class="line"></span><br><span class="line">//gitlab.com/api/v4/projects/31255575/packages/npm/:_authToken=&lt;your_token&gt;</span><br></pre></td></tr></table></figure><p>修改版本号后执行发布命令即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/12/2zwCkZJTmAMbKS9.png" alt="图 4">  </p><p>记录里会标注出是手动发布。</p><h3 id="端点的解释"><a href="#端点的解释" class="headerlink" title="端点的解释"></a>端点的解释</h3><p>点击发布的 npm 包进入详情，其中的 Registry setup 就是本文开头提到的包的端点。</p><p><img src="https://i.loli.net/2021/11/12/yFn34tMJk1TeVxL.png" alt="图 4">  </p><p>项目级和实例级的区别就在于安装地址不同：</p><ul><li>项目级 下载地址必须是带上项目 ID 的地址</li><li>实例级  gitlab 的全局地址，更接近我们平时使用的 npm 注册表</li></ul><p>那是所有发布的包都支持项目级和实例级端点吗？不是。</p><p>前文中提到需要使用自己的用户名（根命名空间）作为 scope，这其实不是必须的，你可以使用任意字符作为 scope，任意 scope 的话（非根命名空间），这个包在安装时就只支持项目级端点，因为不符合<a href="https://docs.gitlab.com/ee/user/packages/npm_registry/#package-naming-convention">包命名约定</a>，使用实例级安装地址会报 404 error。</p><p>而在发布包时，必须是项目级端点，也就是必须提供一个仓库，作为发布地址。</p><h2 id="使用包"><a href="#使用包" class="headerlink" title="使用包"></a>使用包</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>使用项目级 npm 端点 npm 配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set URL for your scoped packages.</span></span><br><span class="line"><span class="comment"># For example package with name `@foo/bar` will use this URL for download</span></span><br><span class="line">npm config <span class="built_in">set</span> @foo:registry https://gitlab.example.com/api/v4/projects/&lt;your_project_id&gt;/packages/npm/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the token for the scoped packages URL. Replace &lt;your_project_id&gt;</span></span><br><span class="line"><span class="comment"># with the project where your package is located.</span></span><br><span class="line">npm config <span class="built_in">set</span> -- <span class="string">&#x27;//gitlab.example.com/api/v4/projects/&lt;your_project_id&gt;/packages/npm/:_authToken&#x27;</span> <span class="string">&quot;&lt;your_token&gt;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用实例级 npm 端点 npm 配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set URL for your scoped packages.</span></span><br><span class="line"><span class="comment"># For example package with name `@foo/bar` will use this URL for download</span></span><br><span class="line">npm config <span class="built_in">set</span> @foo:registry https://gitlab.example.com/api/v4/packages/npm/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the token for the scoped packages URL. This will allow you to download</span></span><br><span class="line"><span class="comment"># `@foo/` packages from private projects.</span></span><br><span class="line">npm config <span class="built_in">set</span> -- <span class="string">&#x27;//gitlab.example.com/api/v4/packages/npm/:_authToken&#x27;</span> <span class="string">&quot;&lt;your_token&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>配置好后直接安装即可。想更详细了解可见<a href="https://git.smartahc.com/help/user/packages/npm_registry/index#project-level-npm-endpoint">官方文档</a>。</p><h3 id="工作区安装"><a href="#工作区安装" class="headerlink" title="工作区安装"></a>工作区安装</h3><p>随处找个地创建一个新文件夹。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ues-hex2rgb &amp;&amp; <span class="built_in">cd</span> ues-hex2rgb</span><br></pre></td></tr></table></figure><p>初始化项目，全默认。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>执行上图 Registry setup 的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> @mubeisama:registry=https://gitlab.com/api/v4/packages/npm/ &gt;&gt; .npmrc</span><br></pre></td></tr></table></figure><p>如果是公开的仓库，执行安装命令即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @mubeisama/hex2rgb</span><br></pre></td></tr></table></figure><p>如果是私有仓库，还需要编辑 <code>.npmrc</code>，添加鉴权配置，再执行安装命令。</p><figure class="highlight sh"><figcaption><span>.npmrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@mubeisama:registry=https://gitlab.com/api/v4/packages/npm/</span><br><span class="line"><span class="comment"># add auth token</span></span><br><span class="line">//gitlab.com/api/v4/packages/npm/:_authToken=&lt;your_token&gt;</span><br></pre></td></tr></table></figure><p>添加 <code>/app.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hex2rgb = <span class="built_in">require</span>(<span class="string">&#x27;@mubeisama/hex2rgb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rgb = hex2rgb(<span class="string">&#x27;#dd2b0e&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;rbg：&#x27;</span>, rgb)</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br><span class="line"><span class="comment"># rbg： rbg(221, 43, 14)</span></span><br></pre></td></tr></table></figure><p>打印正常，收工。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>官方文档：<a href="https://docs.gitlab.com/ee/user/packages/npm_registry/">https://docs.gitlab.com/ee/user/packages/npm_registry/</a></p><p>项目地址：<a href="https://gitlab.com/MuBeiSAMA/hex2rgb">https://gitlab.com/MuBeiSAMA/hex2rgb</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间公司私有化部署的 gitlab 更新了下，发现 gitlab 支持 npm 的包管理了。&lt;/p&gt;
&lt;p&gt;随即打算把私服 nexus 上的 npm 包迁移一下，于是有了这篇文章。&lt;/p&gt;
&lt;p&gt;这篇文章会以 gitlab 官网为示例逐步介绍如何在 gitlab 中发布和使用自己的 npm 包。&lt;/p&gt;
&lt;p&gt;除 npm 以外，gitlab 还支持大多数常见的包管理器，如 Go、Maven、Ruby Gems 等。&lt;/p&gt;</summary>
    
    
    
    <category term="技术方案" scheme="https://mubeisama.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="gitlab" scheme="https://mubeisama.github.io/tags/gitlab/"/>
    
    <category term="npm" scheme="https://mubeisama.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Vue 3.0 入门</title>
    <link href="https://mubeisama.github.io/2020/12/10/Vue%203.0%20%E5%85%A5%E9%97%A8/"/>
    <id>https://mubeisama.github.io/2020/12/10/Vue%203.0%20%E5%85%A5%E9%97%A8/</id>
    <published>2020-12-10T01:19:00.000Z</published>
    <updated>2023-03-06T17:06:14.485Z</updated>
    
    <content type="html"><![CDATA[<div align=center><img alt="v3.0.0 One Piece" src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png"/></div><h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API #"></a>Composition API <a href="https://vue-composition-api-rfc.netlify.app/#summary">#</a></h3><p>提供了一种<code>SFC（单文件组件）</code>写法之外的实现方式</p><p>增加了 <code>setup</code> 语法和相关<a href="https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-script-setup.md">语法糖</a>[实验性]</p><a id="more"></a><h3 id="teleport（传送）"><a href="#teleport（传送）" class="headerlink" title="teleport（传送）"></a>teleport（传送）</h3><p>将组件中的 <code>DOM</code> 挂载到 <code>body</code> 或指定 <code>DOM</code></p><p><code>position: fixed</code>，<code>z-index</code> 等问题</p><h3 id="Fragments（片段）"><a href="#Fragments（片段）" class="headerlink" title="Fragments（片段）"></a>Fragments（片段）</h3><p>在Vue 3中，组件现已正式支持多根节点组件</p><h3 id="Emits-Component-Option"><a href="#Emits-Component-Option" class="headerlink" title="Emits Component Option"></a>Emits Component Option</h3><p>新的组件选项：emits，和 props 一样，通过对象的写法，可以对方法进行验证</p><p>目前没有语法提示</p><p>验证失败会在控制台抛出 <code>[Vue warn]</code></p><h3 id="scoped-styles"><a href="#scoped-styles" class="headerlink" title="scoped-styles"></a>scoped-styles</h3><p>深度选择器<code>&gt;&gt;&gt;</code>和<code>/deep/</code>支持已弃用，他们仅被Vue的SFC编译器用作编译时提示以重写选择器，并在最终CSS中被删除。</p><p>::v-deep 不推荐用作选择器</p><p>原来的选择器有各种兼容问题，CSS伪元素实际上在语义上不是选择器。与惯用CSS相比，伪元素可以接受参数更一致</p><ul><li>深度选择器</li><li>插槽选择器：在 Vue3 中默认使子组件的样式不影响插槽的内容，为了明确地指定插槽内容，可以使用该选择器</li><li>全局选择器：在 <code>scoped style</code> 中声明全局样式。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* deep selectors */</span></span></span><br><span class="line"><span class="css"><span class="selector-pseudo">::v-deep(.foo)</span> &#123;&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/* shorthand */</span></span></span><br><span class="line"><span class="css"><span class="selector-pseudo">:deep(.foo)</span> &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="css"><span class="comment">/* targeting slot content */</span></span></span><br><span class="line"><span class="css"><span class="selector-pseudo">::v-slotted(.foo)</span> &#123;&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/* shorthand */</span></span></span><br><span class="line"><span class="css"><span class="selector-pseudo">:slotted(.foo)</span> &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="css"><span class="comment">/* one-off global rule */</span></span></span><br><span class="line"><span class="css"><span class="selector-pseudo">::v-global(.foo)</span> &#123;&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/* shorthand */</span></span></span><br><span class="line"><span class="css"><span class="selector-pseudo">:global(.foo)</span> &#123;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="style-variables-【实验性】"><a href="#style-variables-【实验性】" class="headerlink" title="style-variables 【实验性】"></a>style-variables 【实验性】</h3><p>允许在 <code>css</code> 中使用可响应变量</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      color: <span class="string">&#x27;red&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">vars</span>=<span class="string">&quot;&#123; color &#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.text</span> &#123;</span></span><br><span class="line">  color: var(--color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;--color:red&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果同时使用了 scoped 和 vars，则所有变量都是本地变量，可以使用 <code>global:</code> 前缀来使用全局变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">vars</span>=<span class="string">&quot;&#123; color &#125;&quot;</span>&gt;</span></span><br><span class="line">h1 &#123;</span><br><span class="line">  color: var(--color);</span><br><span class="line"><span class="css">  <span class="selector-tag">font-size</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--global</span><span class="selector-pseudo">:fontSize)</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新提案：<a href="https://github.com/vuejs/rfcs/pull/231">SFC style CSS variable injection (new edition)</a></p><h2 id="破坏性改动"><a href="#破坏性改动" class="headerlink" title="破坏性改动"></a>破坏性改动</h2><h3 id="移除全局-Vue"><a href="#移除全局-Vue" class="headerlink" title="移除全局 Vue"></a>移除全局 Vue</h3><p>为了避免全局污染，提供新的API <code>createApp</code> 来返回应用实例</p><p>此改动会导致：</p><ol><li>无法通过原型链（prototype）挂载，新增 <code>config.globalProperties</code> 替代挂载原型链操作</li><li>插件无法自安装</li></ol><p>可以自定义工厂函数来为所有应用共享配置</p><h3 id="Global-API-Treeshaking"><a href="#Global-API-Treeshaking" class="headerlink" title="Global API Treeshaking #"></a>Global API Treeshaking <a href="https://www.webpackjs.com/guides/tree-shaking/">#</a></h3><blockquote><p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。</p></blockquote><p>受影响的API：</p><ul><li>Vue.nextTick (<code>&lt;Promise&gt;</code>)</li><li>Vue.observable（替换为Vue.reactive）</li><li>Vue.version</li><li>Vue.compile （仅完整版本）</li><li>Vue.set （仅在兼容版本中）</li><li>Vue.delete （仅在兼容版本中）</li></ul><p>除此之外，许多内部组件/帮助器现在也以命名导出的形式导出，当你使用时才导出功能代码，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>被编译成类似于以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, Transition, withDirectives, vShow &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(Transition, [withDirectives(h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>), [[vShow, <span class="built_in">this</span>.ok]])])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除-filters"><a href="#移除-filters" class="headerlink" title="移除 filters"></a>移除 filters</h3><p>使用 计算属性 <code>computed</code> 或调用函数处理</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ol><li>移除 <code>v-bind</code> 的 <code>.sync</code> 修饰符</li><li>移除组件的 <code>model</code> 选项</li><li>一个组件可以绑定多个 <code>v-model</code></li><li>自定义组件上使用时，<code>v-model</code> 的 props 和 event 默认名称已改为：<ul><li>props: <code>value</code> -&gt; <code>modelValue</code></li><li>event: <code>input</code> -&gt; <code>update:modelValue</code></li></ul></li></ol><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ol><li><p>key：<code>&lt;template v-for&gt;</code> key 应放置在<code>&lt;template&gt;</code>标签上</p></li><li><p>修饰符：</p><ul><li>v-on不再支持使用数字（即keyCodes）作为修饰符</li><li>v-on.native 已删除，现在组件所有事件都会在根元素添加监听</li></ul></li><li><p>props：props default 不能访问 this</p></li><li><p>事件：<code>$on</code>，<code>$off</code>和<code>$once</code>被删除，不再支持事件巴士写法</p></li><li><p>过渡：<code>v-enter</code> 过渡类名改为 <code>v-enter-from</code>，<code>v-leave</code> 过渡类改为 <code>v-leave-from</code></p></li><li><p>移除了 <code>Functional Component</code>，两者差别在<code>vue3</code>可以忽略不计</p></li><li><p>指令优先级：</p><ol><li><code>v-for</code> 高于 <code>v-if</code> -&gt; <code>v-if</code> 优先级始终高于 <code>v-for</code></li><li>单个属性始终覆盖 <code>v-bind=&quot;object&quot;</code> -&gt; 根据绑定的声明顺序决定</li></ol></li><li><p><code>watch</code> 数组时，只有数组在被替换时才会触发 <code>handler</code>，如果想要监听数组内部改动，需要使用 <code>deep: true</code></p></li><li><p>生命周期选项 <code>destroyed</code> 已更名为 <code>unmounted</code>，<code>beforeDestroy</code> 更名为 <code>beforeUnmount</code></p></li></ol><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>defineProperty -&gt; proxy</p><p>Proxy: 代理是一个包含另一个对象或功能并允许您对其进行拦截的对象</p><p>只能兼容到 IE 11</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://v3.vuejs.org/">Vue3 官方文档</a></p><p><a href="https://v3.vuejs.org/guide/migration/introduction.html">Vue2 进阶指南</a></p><p><a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">Vue rfcs（意见征求稿）</a></p>]]></content>
    
    
    <summary type="html">&lt;div align=center&gt;
&lt;img alt=&quot;v3.0.0 One Piece&quot; src=&quot;https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png&quot;/&gt;
&lt;/div&gt;

&lt;h2 id=&quot;新功能&quot;&gt;&lt;a href=&quot;#新功能&quot; class=&quot;headerlink&quot; title=&quot;新功能&quot;&gt;&lt;/a&gt;新功能&lt;/h2&gt;&lt;h3 id=&quot;Composition-API&quot;&gt;&lt;a href=&quot;#Composition-API&quot; class=&quot;headerlink&quot; title=&quot;Composition API #&quot;&gt;&lt;/a&gt;Composition API &lt;a href=&quot;https://vue-composition-api-rfc.netlify.app/#summary&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;提供了一种&lt;code&gt;SFC（单文件组件）&lt;/code&gt;写法之外的实现方式&lt;/p&gt;
&lt;p&gt;增加了 &lt;code&gt;setup&lt;/code&gt; 语法和相关&lt;a href=&quot;https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-script-setup.md&quot;&gt;语法糖&lt;/a&gt;[实验性]&lt;/p&gt;</summary>
    
    
    
    <category term="技术方案" scheme="https://mubeisama.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="vue-next" scheme="https://mubeisama.github.io/tags/vue-next/"/>
    
    <category term="vue" scheme="https://mubeisama.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>钉钉配置化流程调研</title>
    <link href="https://mubeisama.github.io/2020/07/30/%E9%92%89%E9%92%89%E9%85%8D%E7%BD%AE%E5%8C%96%E6%B5%81%E7%A8%8B%E8%B0%83%E7%A0%94/"/>
    <id>https://mubeisama.github.io/2020/07/30/%E9%92%89%E9%92%89%E9%85%8D%E7%BD%AE%E5%8C%96%E6%B5%81%E7%A8%8B%E8%B0%83%E7%A0%94/</id>
    <published>2020-07-30T02:47:00.000Z</published>
    <updated>2021-04-15T09:08:32.026Z</updated>
    
    <content type="html"><![CDATA[<!-- ![功能页](https://i.loli.net/2020/07/29/wh1XG5IUeDyg9Hz.png) --><p>配置化流程，实际上就是根据配置好的数据，动态创建表单。</p><p>流程上大致可以分为：</p><ol><li>图形化的表单数据配置和创建</li><li>表单数据存储和展示</li><li>通过数据创建表单</li></ol><p>需要实现两个主要功能：</p><a id="more"></a><ol><li>图形化表单编辑器</li><li>表单生成器</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>钉钉有审核流程的设计，如果不考虑审核流程的话，和 AIoT 的自定义字段功能相差不多。</p><h3 id="图形化表单编辑器"><a href="#图形化表单编辑器" class="headerlink" title="图形化表单编辑器"></a>图形化表单编辑器</h3><p>这块实现起来大致分为三个部分：</p><ol><li>控件预定义</li><li>控件拖拽</li><li>控件编辑</li></ol><h4 id="控件预定义"><a href="#控件预定义" class="headerlink" title="控件预定义"></a>控件预定义</h4><p>对于常用的输入控件的具象化。</p><p>配置型表单首要解决的问题就是控件差异性和控件数据处理。</p><p>对于常用的控件，例如定位、身份证输入框和部门选择之类的，可以先定义好样式和数据的配置，供配置时直接选用。</p><p>另外，对于操作复杂、关联性强的控件，可以预定义一套配置，作为套件。</p><h4 id="控件拖拽"><a href="#控件拖拽" class="headerlink" title="控件拖拽"></a>控件拖拽</h4><p>图形化配置关键功能，有已实现的成熟开源库，效果如下：</p><p><img src="https://i.loli.net/2020/07/29/ynoEqlv6PYTr4Hj.gif" alt="拖拽效果"></p><h4 id="控件编辑"><a href="#控件编辑" class="headerlink" title="控件编辑"></a>控件编辑</h4><p>对于控件各种配置的预置。</p><p>简单点的有 placeholder、label 之类的设置，复杂点的有级联选择器的数据、日期控件的 format 等。</p><p>也可以在这一步预置控件的值。</p><h3 id="表单生成器"><a href="#表单生成器" class="headerlink" title="表单生成器"></a>表单生成器</h3><p>选定 UI 框架，再拿到设定好的配置，就可以生成表单了，这一步最简单，不做赘述。</p><p>复杂的地方在于配置的定义和控件字段。</p><p><strong>配置定义</strong>：比较好理解，就是对于控件的一些数据定义下字段，比如选择器的 options 列表，默认选择的项、标题、宽度之类的。控件种类越多，需要定义的字段也就越多。</p><p><strong>控件字段</strong>：因为可能存在相同类型的重复控件，所以控件的字段名要用一个不重复的代号表示。这样在往数据库里存的时候就会有点小问题。一是不知道这个字段内容的具体意义，二是字段和数据库字段肯定对不上，只能转为 string json 存在记录某个字段里。只有配合表单配置这个数据才有意义。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这样一个项目复杂度不低，好在已经有不少开源库实现了类似功能。</p><h3 id="form-generator"><a href="#form-generator" class="headerlink" title="form-generator"></a><a href="https://github.com/JakHuang/form-generator">form-generator</a></h3><blockquote><p>Element UI表单设计及代码生成器</p></blockquote><p><img src="https://i.loli.net/2020/07/29/Xzidg7K9PurpHID.png" alt="image.png"></p><p>可以满足配置化表单的基本需求。</p><p>不过不支持 antd，没有审核流程。</p><h3 id="approvalFlow"><a href="#approvalFlow" class="headerlink" title="approvalFlow"></a><a href="https://github.com/SNFocus/approvalFlow">approvalFlow</a></h3><blockquote><p>基于form-generator，仿钉钉审批流程创建（表单创建/流程节点可视化配置/必填条件及校验）</p></blockquote><p><img src="https://i.loli.net/2020/07/29/1wg62uPvEk5f83Q.png" alt="image.png"></p><p><code>图形化表单编辑器</code>和<code>表单生成器</code>都有，完全符合需求，MIT 开源协议，基于 form-generator，同样不支持 antd，可以基于这个项目做些个性化开发。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![功能页](https://i.loli.net/2020/07/29/wh1XG5IUeDyg9Hz.png) --&gt;

&lt;p&gt;配置化流程，实际上就是根据配置好的数据，动态创建表单。&lt;/p&gt;
&lt;p&gt;流程上大致可以分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图形化的表单数据配置和创建&lt;/li&gt;
&lt;li&gt;表单数据存储和展示&lt;/li&gt;
&lt;li&gt;通过数据创建表单&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要实现两个主要功能：&lt;/p&gt;</summary>
    
    
    
    <category term="技术方案" scheme="https://mubeisama.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="钉钉" scheme="https://mubeisama.github.io/tags/%E9%92%89%E9%92%89/"/>
    
    <category term="表单配置化" scheme="https://mubeisama.github.io/tags/%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%E5%8C%96/"/>
    
    <category term="低代码" scheme="https://mubeisama.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【国际化】自动提取语言配置文件及使用</title>
    <link href="https://mubeisama.github.io/2020/04/22/%E3%80%90%E5%A4%9A%E8%AF%AD%E8%A8%80%E3%80%91%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://mubeisama.github.io/2020/04/22/%E3%80%90%E5%A4%9A%E8%AF%AD%E8%A8%80%E3%80%91%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-22T11:06:52.000Z</published>
    <updated>2023-03-06T17:06:10.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="i18next-scanner"><a href="#i18next-scanner" class="headerlink" title="i18next-scanner"></a><a href="https://github.com/i18next/i18next-scanner">i18next-scanner</a></h3><p>node插件，扫描您的代码，提取翻译键/值，然后将它们合并到i18n资源文件中。</p><h3 id="vue-i18n"><a href="#vue-i18n" class="headerlink" title="vue-i18n"></a><a href="https://github.com/kazupon/vue-i18n">vue-i18n</a></h3><p>Vue.js 的国际化插件，提供本地化相关功能，集成在vue当中。</p><h2 id="i18next-scanner-使用"><a href="#i18next-scanner-使用" class="headerlink" title="i18next-scanner 使用"></a>i18next-scanner 使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add i18next-scanner -D</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="添加到-package-json-scripts"><a href="#添加到-package-json-scripts" class="headerlink" title="添加到 package.json scripts"></a>添加到 package.json scripts</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;scan&quot;: &quot;i18next-scanner&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>i18next-scanner 指令会寻找当前目录下的 i18next-scanner.config.js 文件，缺少就会报错。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; crc32 &#125; = <span class="built_in">require</span>(<span class="string">&#x27;crc&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  input: [</span><br><span class="line">    <span class="string">&#x27;src/**/*.&#123;js,vue&#125;&#x27;</span>,</span><br><span class="line">    <span class="comment">// Use ! to filter out files or directories</span></span><br><span class="line">    <span class="string">&#x27;!src/config/i18n/**&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;!**/node_modules/**&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  output: <span class="string">&#x27;./&#x27;</span>, <span class="comment">// 输出目录</span></span><br><span class="line">  options: &#123;</span><br><span class="line">    debug: <span class="literal">true</span>,</span><br><span class="line">    func: <span class="literal">false</span>,</span><br><span class="line">    trans: <span class="literal">false</span>,</span><br><span class="line">    lngs: [<span class="string">&#x27;cn&#x27;</span>, <span class="string">&#x27;en&#x27;</span>],</span><br><span class="line">    defaultLng: <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">    resource: &#123;</span><br><span class="line">      loadPath: <span class="string">&#x27;./src/config/i18n/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;</span>, <span class="comment">// 输入路径</span></span><br><span class="line">      savePath: <span class="string">&#x27;./src/config/i18n/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json&#x27;</span>, <span class="comment">// 输出路径</span></span><br><span class="line">      jsonIndent: <span class="number">2</span>,</span><br><span class="line">      lineEnding: <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    removeUnusedKeys: <span class="literal">false</span>, <span class="comment">// 移除未使用的 key</span></span><br><span class="line">    nsSeparator: <span class="literal">false</span>, <span class="comment">// namespace separator</span></span><br><span class="line">    keySeparator: <span class="literal">false</span>, <span class="comment">// key separator</span></span><br><span class="line">    interpolation: &#123;</span><br><span class="line">      prefix: <span class="string">&#x27;&#123;&#123;&#x27;</span>,</span><br><span class="line">      suffix: <span class="string">&#x27;&#125;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  transform: <span class="function"><span class="keyword">function</span> <span class="title">customTransform</span>(<span class="params">file, enc, done</span>) </span>&#123; <span class="comment">// 自己通过该函数来加工key或value</span></span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> parser = <span class="built_in">this</span>.parser</span><br><span class="line">    <span class="keyword">const</span> content = fs.readFileSync(file.path, enc)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;list&#125;</span> </span>array 指定扫描的标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    parser.parseFuncFromString(content, &#123; <span class="attr">list</span>: [<span class="string">&#x27;lang&#x27;</span>] &#125;, <span class="function">(<span class="params">key, options</span>) =&gt;</span> &#123;</span><br><span class="line">      options.defaultValue = key</span><br><span class="line">      <span class="comment">// 将传入的文字转成配置的 key，不一定非用 crc，别的也行，如果内容不会影响 json 格式，不用也行</span></span><br><span class="line">      <span class="keyword">let</span> hashKey = <span class="string">`k<span class="subst">$&#123;crc32(key).toString(<span class="number">16</span>)&#125;</span>`</span></span><br><span class="line">      parser.set(hashKey, options)</span><br><span class="line">    &#125;)</span><br><span class="line">    done()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件添加之后， i18next-scanner 就能使扫描文字了，运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn scan</span><br></pre></td></tr></table></figure><p>会根据配置中的语言空间导出到对应的文件夹，导出的文件长这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;kee8ae330&quot;</span>: <span class="string">&quot;查询&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;k50d471b2&quot;</span>: <span class="string">&quot;重置&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;kebceb256&quot;</span>: <span class="string">&quot;修改中...&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;k2d46b71b&quot;</span>: <span class="string">&quot;删除中...&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;kb135e9bd&quot;</span>: <span class="string">&quot;下载中...&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ked2baf28&quot;</span>: <span class="string">&quot;加载中...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过以上方式，实现中文作为代码中的多语言的key，而且用中文作为key不会导致索引语言包导致的性能或索取不准确的问题，因为中文会先转化为crc32的key然后对象的再去索引同样以crc32为key的语言包，这样可以实现中文作为代码中的key，却实际上还是以准备的hashkey来索引语言包。</p></blockquote><p>这样就不需要自己写配置文件，使用的时候再一个个去对了，直接在需要使用多语言的地方加上扫描标识方法就能本地化。</p><h2 id="i18n-使用"><a href="#i18n-使用" class="headerlink" title="i18n 使用"></a>i18n 使用</h2><h3 id="i18n-index-js"><a href="#i18n-index-js" class="headerlink" title="i18n index.js"></a>i18n index.js</h3><p>通过 lang 方法，将文字再转为 key，lang() 同时也是 i18next-scanner 扫描标识。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span></span><br><span class="line"><span class="keyword">import</span> en <span class="keyword">from</span> <span class="string">&#x27;./en/translation.json&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cn <span class="keyword">from</span> <span class="string">&#x27;./cn/translation.json&#x27;</span></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">&#x27;crc/crc32&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 语言包导入 */</span></span><br><span class="line">Vue.use(VueI18n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n(&#123;</span><br><span class="line">  locale: <span class="string">&#x27;cn&#x27;</span>, <span class="comment">// set locale</span></span><br><span class="line">  messages: &#123;</span><br><span class="line">    cn,</span><br><span class="line">    en</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lang</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hashKey = <span class="string">`k<span class="subst">$&#123;crc32(key).toString(<span class="number">16</span>)&#125;</span>`</span></span><br><span class="line">  <span class="keyword">let</span> words = i18n.t(hashKey)</span><br><span class="line">  <span class="keyword">if</span> (words === hashKey) &#123;</span><br><span class="line">    words = key</span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="string">&#x27;-没翻译&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> words</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> i18n, &#123; lang &#125; <span class="keyword">from</span> <span class="string">&#x27;./config/i18n/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$lang = lang</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; ..., i18n &#125;)</span><br></pre></td></tr></table></figure><h3 id="代码中使用"><a href="#代码中使用" class="headerlink" title="代码中使用"></a>代码中使用</h3><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;&#123; $lang(&#x27;查询&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hide = <span class="built_in">this</span>.$message.loading(<span class="built_in">this</span>.$lang(<span class="string">&#x27;修改中...&#x27;</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>至此就大功告成了</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="微前端中动态切换语言"><a href="#微前端中动态切换语言" class="headerlink" title="微前端中动态切换语言"></a>微前端中动态切换语言</h3><p>主项目中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lang&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;switchLang&quot;</span>&gt;</span>&#123;&#123; langConfig[lang] &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      langConfig: &#123;</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;cn&#x27;</span>: <span class="string">&#x27;English&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;en&#x27;</span>: <span class="string">&#x27;中文&#x27;</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      lang: <span class="string">&#x27;cn&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">switchLang</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.lang = <span class="built_in">this</span>.lang === <span class="string">&#x27;cn&#x27;</span> ? <span class="string">&#x27;en&#x27;</span> : <span class="string">&#x27;cn&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$root.storeModule.commit(<span class="string">&#x27;setLang&#x27;</span>, <span class="built_in">this</span>.lang)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// i18n 的实例方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$i18n.locale = <span class="built_in">this</span>.lang</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子项目 App.vue 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-locale-provider</span> <span class="attr">:locale</span>=<span class="string">&quot;locale&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-locale-provider</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue/lib/locale-provider/zh_CN&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> enUS <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue/lib/locale-provider/en_US&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      locale: zhCN</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line"><span class="javascript">    <span class="string">&#x27;$root.storeModule.state.lang&#x27;</span>(lang) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;call $root.storeModule.state.lang&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$i18n.locale = lang</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.locale = lang === <span class="string">&#x27;cn&#x27;</span> ? zhCN : enUS</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比传统 i18n 做法的优点：</p><ol><li>省时省力，不再需要创建配置文件后挨个匹配路径</li><li>可读性更好，本地化的位置直接就是中文汉字，不会因为丢失文字而不知其意</li><li>效率高、成本低、开发无感，只需要把本地化的地方加上标识，扫描后的文件翻译即可</li></ol><p>对比传统 i18n 做法的缺点：</p><ol><li>灵活性稍微降低，使用中文作为配置的 key，会导致一样的中文都是一样的 key，那么翻译也会一样。当出现位置不同，中文相同，而翻译想要更明确时，会比较麻烦</li><li>配置文件较大，一种语言空间的配置都在一个 json 中，没法同种语言多个配置按需加载</li></ol><p>另外，<code>i18next-scanner</code> 还有一个很大的缺陷，它只能通过 <code>function</code> 和 <code>attr</code> 来标识提取的内容</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>i18next-scanner <a href="https://github.com/i18next/i18next-scanner">https://github.com/i18next/i18next-scanner</a></p><p>vue-i18n <a href="https://github.com/kazupon/vue-i18n">https://github.com/kazupon/vue-i18n</a></p><p>zcmzks vue或react多语言自动化实现扫描代码的多语言-i18next-scanner <a href="https://www.cnblogs.com/jocongmin/articles/12716786.html">https://www.cnblogs.com/jocongmin/articles/12716786.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;h3 id=&quot;i18next-scanner&quot;&gt;&lt;a href=&quot;#i18next-scanner&quot; class=&quot;headerlink&quot; title=&quot;i18next-scanner&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/i18next/i18next-scanner&quot;&gt;i18next-scanner&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;node插件，扫描您的代码，提取翻译键/值，然后将它们合并到i18n资源文件中。&lt;/p&gt;
&lt;h3 id=&quot;vue-i18n&quot;&gt;&lt;a href=&quot;#vue-i18n&quot; class=&quot;headerlink&quot; title=&quot;vue-i18n&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/kazupon/vue-i18n&quot;&gt;vue-i18n&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Vue.js 的国际化插件，提供本地化相关功能，集成在vue当中。&lt;/p&gt;
&lt;h2 id=&quot;i18next-scanner-使用&quot;&gt;&lt;a href=&quot;#i18next-scanner-使用&quot; class=&quot;headerlink&quot; title=&quot;i18next-scanner 使用&quot;&gt;&lt;/a&gt;i18next-scanner 使用&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yarn add i18next-scanner -D&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术方案" scheme="https://mubeisama.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="vue" scheme="https://mubeisama.github.io/tags/vue/"/>
    
    <category term="i18n" scheme="https://mubeisama.github.io/tags/i18n/"/>
    
    <category term="国际化" scheme="https://mubeisama.github.io/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
    <category term="js" scheme="https://mubeisama.github.io/tags/js/"/>
    
    <category term="插件" scheme="https://mubeisama.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
    <category term="i18next-scanner" scheme="https://mubeisama.github.io/tags/i18next-scanner/"/>
    
    <category term="vue-i18n" scheme="https://mubeisama.github.io/tags/vue-i18n/"/>
    
  </entry>
  
  <entry>
    <title>多平台微信统一登陆</title>
    <link href="https://mubeisama.github.io/2020/03/09/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
    <id>https://mubeisama.github.io/2020/03/09/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/</id>
    <published>2020-03-09T02:57:00.000Z</published>
    <updated>2021-04-15T07:20:24.671Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对各平台登陆和 unionid 获取稍做介绍。时效，权限等问题可在参考链接中了解详情</p></blockquote><h2 id="unionid-机制说明"><a href="#unionid-机制说明" class="headerlink" title="unionid 机制说明"></a>unionid 机制说明</h2><blockquote><p>用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的unionid是唯一的。</p></blockquote><p>如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。</p><h2 id="登陆流程-amp-unionid-获取"><a href="#登陆流程-amp-unionid-获取" class="headerlink" title="登陆流程 &amp; unionid 获取"></a>登陆流程 &amp; unionid 获取</h2><a id="more"></a><p>微信登陆场景大致分为 app、公众号、小程序和 web pc 端。在流程上除了小程序比较特殊外，其他基本一致。</p><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><h4 id="登陆-amp-敏感数据获取"><a href="#登陆-amp-敏感数据获取" class="headerlink" title="登陆 &amp; 敏感数据获取"></a>登陆 &amp; 敏感数据获取</h4><ol><li><p>小程序端调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html">wx.login()</a> 获取 <strong>临时登录凭证code</strong>（有效期五分钟） ，并回传到服务端。</p></li><li><p>服务端调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">auth.code2Session</a> 接口，换取 <strong>用户唯一标识 OpenID</strong> 和 <strong>会话密钥 session_key</strong>。</p></li><li><p>小程序端带上登陆态参数 <code>&#123;withCredentials: true&#125;</code> 调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html">wx.getUserInfo()</a> 接口，获取解密时所需的 <strong>加密算法的初始向量 iv</strong> 和 包括敏感数据在内的完整用户信息的 <strong>加密数据 encryptedData</strong>，并回传到服务端。需要注意的是，要求此前调用过 wx.login 且登陆态尚未过期，返回的数据才会包含 encryptedData, iv 等信息。</p></li></ol><h4 id="加密数据解密算法"><a href="#加密数据解密算法" class="headerlink" title="加密数据解密算法"></a>加密数据解密算法</h4><p>服务端对 <strong>加密数据（encryptedData）</strong> 进行对称解密，即可获取用户的 openId 和 <strong>unionId</strong>。解密算法如下：</p><ol><li>对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。</li><li>对称解密的目标密文为 Base64_Decode(encryptedData)。</li><li>对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。</li><li>对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。</li></ol><p>微信官方提供了多种编程语言的示例代码（<a href="https://res.wx.qq.com/wxdoc/dist/assets/media/aes-sample.eae1f364.zip">点击下载</a>）。每种语言类型的接口名字均一致。调用方式可以参照示例。</p><p>另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印(watermark)</p><h3 id="web-pc-端"><a href="#web-pc-端" class="headerlink" title="web pc 端"></a>web pc 端</h3><p>微信登录基于OAuth2.0协议标准构建的微信OAuth2.0授权登录系统。 需要提前在 <a href="https://open.weixin.qq.com/">微信开放平台</a> 注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的 AppID 和 AppSecret，申请微信登录且通过审核后，可开始接入流程。</p><h4 id="获取-code"><a href="#获取-code" class="headerlink" title="获取 code"></a>获取 code</h4><h5 id="方式一-跳转到指定链接获取授权"><a href="#方式一-跳转到指定链接获取授权" class="headerlink" title="方式一 跳转到指定链接获取授权"></a>方式一 跳转到指定链接获取授权</h5><p>访问 <a href="https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a> 请求 code。 参数来源于开放平台中对网站应用。</p><h5 id="方式二-页面内微信登陆二维码"><a href="#方式二-页面内微信登陆二维码" class="headerlink" title="方式二 页面内微信登陆二维码"></a>方式二 页面内微信登陆二维码</h5><ol><li>在页面中先引入如下JS文件（支持https）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;res.wx.qq.com&#x2F;connect&#x2F;zh_CN&#x2F;htmledition&#x2F;js&#x2F;wxLogin.js</span><br></pre></td></tr></table></figure><ol start="2"><li>在需要使用微信登录的地方实例以下JS对象：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> WxLogin(&#123;</span><br><span class="line">  self_redirect: <span class="literal">true</span>, <span class="comment">// true：手机点击确认登录后可以在 iframe 内跳转到 redirect_uri，false：手机点击确认登录后可以在 top window 跳转到 redirect_uri。默认为 false。</span></span><br><span class="line">  id: <span class="string">&quot;login_container&quot;</span>, <span class="comment">// 【必填】 第三方页面显示二维码的容器id</span></span><br><span class="line">  appid: <span class="string">&quot;&quot;</span>, <span class="comment">// 【必填】应用唯一标识，在微信开放平台提交应用审核通过后获得</span></span><br><span class="line">  scope: <span class="string">&quot;&quot;</span>, <span class="comment">// 【必填】应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可</span></span><br><span class="line">  redirect_uri: <span class="string">&quot;&quot;</span>, <span class="comment">// 【必填】重定向地址，需要进行UrlEncode</span></span><br><span class="line">  state: <span class="string">&quot;&quot;</span>, <span class="comment">// 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验</span></span><br><span class="line">  style: <span class="string">&quot;&quot;</span>, <span class="comment">// 提供&quot;black&quot;、&quot;white&quot;可选，默认为黑色文字描述。</span></span><br><span class="line">  href: <span class="string">&quot;&quot;</span> <span class="comment">// 自定义样式链接，第三方可根据实际需求覆盖默认样式。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上两种方式，用户允许授权后，都将重定向到redirect_uri的网址上，并且带上code和state参数 <code>redirect_uri?code=CODE&amp;state=STATE</code></p><h4 id="access-token-amp-unionid"><a href="#access-token-amp-unionid" class="headerlink" title="access_token &amp; unionid"></a>access_token &amp; unionid</h4><p>通过 code 获取 access_token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token?appid&#x3D;APPID&amp;secret&#x3D;SECRET&amp;code&#x3D;CODE&amp;grant_type&#x3D;authorization_code</span><br></pre></td></tr></table></figure><p>正确的返中即包含 <strong>unionid</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line"><span class="string">&quot;expires_in&quot;</span>:<span class="number">7200</span>,</span><br><span class="line"><span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line"><span class="string">&quot;openid&quot;</span>:<span class="string">&quot;OPENID&quot;</span>,</span><br><span class="line"><span class="string">&quot;scope&quot;</span>:<span class="string">&quot;SCOPE&quot;</span>,</span><br><span class="line"><span class="string">&quot;unionid&quot;</span>: <span class="string">&quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展-调用微信接口"><a href="#拓展-调用微信接口" class="headerlink" title="拓展 调用微信接口"></a>拓展 调用微信接口</h4><p>access_token 是调用授权关系接口的调用凭证，微信提供了许多智能接口，凭借 access_token 即可调用</p><h5 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http请求方式: GET</span><br><span class="line">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo?access_token&#x3D;ACCESS_TOKEN&amp;openid&#x3D;OPENID</span><br></pre></td></tr></table></figure><h5 id="微信智慧接口-语义理解接口"><a href="#微信智慧接口-语义理解接口" class="headerlink" title="微信智慧接口-语义理解接口"></a>微信智慧接口-语义理解接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http请求方式: POST（请使用https协议）</span><br><span class="line">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;semantic&#x2F;semproxy&#x2F;search?access_token&#x3D;YOUR_ACCESS_TOKEN</span><br><span class="line">POST数据格式：JSON</span><br><span class="line">POST数据例子：</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&quot;查一下明天从北京到上海的南航机票&quot;,</span><br><span class="line">&quot;city&quot;:&quot;北京&quot;,</span><br><span class="line">&quot;category&quot;: &quot;flight,hotel&quot;,</span><br><span class="line">&quot;appid&quot;:&quot;wxaaaaaaaaaaaaaaaa&quot;,</span><br><span class="line">&quot;uid&quot;:&quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细可见：<a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Smart_APIs/Semantic_Understanding.html">微信智能接口</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>微信官方文档 - 小程序 UnionID 机制说明 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html</a></p><p>微信官方文档 - 小程序 开放数据校验与解密 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html</a></p><p>微信开放平台 - 网站应用接入 <a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对各平台登陆和 unionid 获取稍做介绍。时效，权限等问题可在参考链接中了解详情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;unionid-机制说明&quot;&gt;&lt;a href=&quot;#unionid-机制说明&quot; class=&quot;headerlink&quot; title=&quot;unionid 机制说明&quot;&gt;&lt;/a&gt;unionid 机制说明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的unionid是唯一的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。&lt;/p&gt;
&lt;h2 id=&quot;登陆流程-amp-unionid-获取&quot;&gt;&lt;a href=&quot;#登陆流程-amp-unionid-获取&quot; class=&quot;headerlink&quot; title=&quot;登陆流程 &amp;amp; unionid 获取&quot;&gt;&lt;/a&gt;登陆流程 &amp;amp; unionid 获取&lt;/h2&gt;</summary>
    
    
    
    <category term="技术方案" scheme="https://mubeisama.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="微信" scheme="https://mubeisama.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
    <category term="auth2" scheme="https://mubeisama.github.io/tags/auth2/"/>
    
    <category term="微信登陆" scheme="https://mubeisama.github.io/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E9%99%86/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序局域网通信</title>
    <link href="https://mubeisama.github.io/2019/09/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/"/>
    <id>https://mubeisama.github.io/2019/09/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/</id>
    <published>2019-09-26T01:58:00.000Z</published>
    <updated>2021-04-15T09:03:00.085Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 mDNS 协议实现 http 和 socket 通信</p></blockquote><p>Windows 上未找到可用的 mDNS 服务发现工具，Linux 上可使用 <a href="http://www.avahi.org/">avahi</a>，MacOS 上可使用 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/NetServices/Introduction.html#//apple_ref/doc/uid/TP40002445-SW1">Bonjour</a>。</p><p>本项目使用 Linux 作为通信终端。</p><p>项目地址：<a href="https://github.com/MuBeiSAMA/lan-communication-mp">https://github.com/MuBeiSAMA/lan-communication-mp</a></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><a id="more"></a><ul><li><p>服务发现</p><ul><li><a href="http://www.avahi.org/">avahi</a></li></ul></li><li><p>server</p><ul><li><a href="https://expressjs.com/zh-cn/">express</a></li><li><a href="https://socket.io/">socket.io</a></li></ul></li><li><p>client</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.stopLocalServiceDiscovery.html">小程序 mDNS 系列 API</a></li><li><a href="https://github.com/10cella/weapp.socket.io">weapp.socket.io</a></li></ul></li></ul><h2 id="服务端（Linux）"><a href="#服务端（Linux）" class="headerlink" title="服务端（Linux）"></a>服务端（Linux）</h2><h3 id="安装-avahi"><a href="#安装-avahi" class="headerlink" title="安装 avahi"></a>安装 avahi</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install avahi-utils</span><br></pre></td></tr></table></figure><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avahi-publish-service -s <span class="string">&quot;yourServiceName&quot;</span> _http._tcp 1111</span><br></pre></td></tr></table></figure><p>参数分别为：服务名称，服务类型，端口号。</p><p>运行后即可在局域网中被发现。</p><h3 id="运行-server"><a href="#运行-server" class="headerlink" title="运行 server"></a>运行 server</h3><p>nodejs，npm 或 yarn 为必备环境，不做赘述。</p><p>先进入 server 文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> server</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yarn</span></span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 npm</span></span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><p>终端打印 <code>listening on *:1111</code> 即表示运行成功，将持续监听 1111 端口，与注册服务时暴露的端口号一致。</p><p>脚本基于 express 和 socket.io 分别提供了 http 和 socket 的通信能力。</p><h2 id="客户端（小程序）"><a href="#客户端（小程序）" class="headerlink" title="客户端（小程序）"></a>客户端（小程序）</h2><p>小程序局域网通信详情可见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html">局域网通信</a>。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始搜索局域网下的 mDNS 服务。搜索的结果会通过 wx.onLocalService* 事件返回。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; object &#125;</span> </span>object.serviceType 必填项 要搜索的服务类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">wx.startLocalServiceDiscovery(&#123;</span><br><span class="line">  serviceType: <span class="string">&#x27;_http._tcp.&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听 mDNS 服务发现的事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>callback 发现了服务的回调，参数为单个服务数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">wx.onLocalServiceFound(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>)</span></span><br></pre></td></tr></table></figure><!-- 主要通过小程序提供的 mDNS 系列 api 实现 --><h3 id="服务数据"><a href="#服务数据" class="headerlink" title="服务数据"></a>服务数据</h3><p>onLocalServiceFound 方法回调中的数据如图：</p><p><img src="https://i.loli.net/2019/09/24/lRuMofBXKeWSaDz.png" alt="server data"></p><p>根据数据中的 ip 和 port 信息，即可进行 http 和 socket 通信。</p><!-- 通过服务中的 ip 与 端口即可建立通信。 --><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>一些 OS 可能不支持 mDNS 服务发现，这时可使用微信开发工具的<strong>真机调试</strong>功能进行调试。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基于 mDNS 协议实现 http 和 socket 通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Windows 上未找到可用的 mDNS 服务发现工具，Linux 上可使用 &lt;a href=&quot;http://www.avahi.org/&quot;&gt;avahi&lt;/a&gt;，MacOS 上可使用 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/NetServices/Introduction.html#//apple_ref/doc/uid/TP40002445-SW1&quot;&gt;Bonjour&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本项目使用 Linux 作为通信终端。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/MuBeiSAMA/lan-communication-mp&quot;&gt;https://github.com/MuBeiSAMA/lan-communication-mp&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;技术栈&quot;&gt;&lt;a href=&quot;#技术栈&quot; class=&quot;headerlink&quot; title=&quot;技术栈&quot;&gt;&lt;/a&gt;技术栈&lt;/h2&gt;</summary>
    
    
    
    <category term="技术方案" scheme="https://mubeisama.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="微信" scheme="https://mubeisama.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
    <category term="微信小程序" scheme="https://mubeisama.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="局域网通信" scheme="https://mubeisama.github.io/tags/%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
</feed>
