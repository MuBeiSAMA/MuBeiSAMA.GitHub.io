{"posts":[{"title":"CSS 基础","text":"Class 命名规范在之前，我们一般遵循 BEM 规范，BEM 即块（block）、元素（element）、修饰符（modifier）。 它的规则是： 块名称为其元素和修饰符定义了命名空间。 块名称与元素名称之间用双连字符–分隔。 块名称与修饰符或元素与修饰符之间用双下划线__分隔。 命名一般使用小写字母。 单词之间可以使用-分隔。 命名约定的模式有如下几种： 1234.block{}.block__element{}.block--modifier{}.block__element--modifier{} 这种规范的好处是： 将界面分块，便于管理，方便复用。 通过精确具体的类名，避免类名污染，防止全局覆盖问题。 在今天，随着 css 框架的流行，更简洁易用的嵌套写法逐渐成为主流，遵循顾名思义原则即可。BEM 精确具体的类名要求也导致写起来冗长繁琐，且嵌套写法也不存在类名污染问题，BEM也就慢慢淡出日常开发了。 组件库之类全局样式多的领域 BEM 这种命名思想还在发光发热，但基本简化为仅以连字符分割（block-element-modifier ）的形式了。 盒模型什么是盒模型？ 浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子。 每个盒子由四个部分：内容（content）、内边距（padding）、边框（border）和外边距（margin）。 盒模型的定义由 box-sizing 属性控制，box-sizing 有两个可用的值： content-box，W3C标准盒模型，默认值。设置元素的宽高只作用于内容（content）。 border-box，IE盒模型，设置元素的宽高包含内容（content）、内边距（padding）和边框（border）。大多数情况下，这使得我们更容易地设定一个元素的宽高。 外边距重叠块的上外边距 (margin-top)和下外边距 (margin-bottom)有时合并 (折叠) 为单个边距，其大小为单个边距的最大值，这种行为称为边距折叠。 注意有设定 float 和 position=absolute 的元素不会产生外边距重叠行为。 有三种情况会形成外边距重叠： 同一层相邻元素之间 没有内容将父元素和后代元素分开 空的块级元素 BFCBFC 是什么？ MDN 的解释是： 块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 听起来很拗口，实际上解释 BFC 的文章也非常多，但众说纷纷，看完也很难理解。 其实 BFC 这个概念并不重要，我们先跳过 BFC 是什么这个问题，来看 BFC 的特性。 MDN 对 BFC 特性的描述有三点： 包含内部浮动 排除外部浮动 阻止外边距重叠 用一句话总结就是：内部子元素不会影响外部元素。记住这句话之后，再来逐个理解。 包含内部浮动默认情况下，内部元素浮动，就会溢出，如下图。 但当父元素为 BFC 时，父元素就会包含子元素的浮动，也就不会溢出造成对外部元素的影响。 排除外部浮动左侧盒子浮动，默认情况下，由于盒子脱离文档流，正常元素会继续从盒子位置排列。 但当正常元素变为 BFC 元素时，为了和外部浮动元素不产生影响，顺着浮动边缘形成了自己的封闭上下文。 这里再放一个张鑫旭大佬的例子： 可以很清楚的看出排除外部浮动这一特性。 阻止外边距重叠 默认情况下 .blue 和 .red-inner 会发生外边距重叠，.red-inner 的 margin 将不生效。 但 .red-outer 添加了 overflow: hidden 变成了 BFC 元素。子元素的边距重叠就被消除了，阻止了对外部元素的影响。 BFC 是什么？理解了特性之后再回到一开始的问题，就好回答了。 BFC 就是特定方式创建的特性元素。 几种常见的创建 BFC 元素的方式： 根元素（&lt;html&gt;） 浮动元素（float 值不为 none） 绝对定位元素（position 值为 absolute 或 fixed） 行内块元素（display 值为 inline-block） 表格单元格（display 值为 table-cell，HTML 表格单元格默认值） overflow 值不为 visible、clip 的块元素 display 值为 flow-root 的元素 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器 多列容器（column-count 或 column-width (en-US) 值不为 auto，包括column-count 为 1） 参考链接https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizinghttps://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_contexthttps://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/","link":"/2022/08/02/CSS%E5%9F%BA%E7%A1%80/"},{"title":"JavaScript 基础","text":"作用域和闭包什么是作用域？ 通常来说一段程序代码中使用的变量和函数并不总是可用的，限定其可用性的范围即作用域。 通俗来说，作用域就是函数和变量起作用的区域。 js 存在三种作用域： 全局作用域。声明在函数和代码块之外的变量（在全局的任意地方都可以调用或修改），和在 window 下的属性。 函数作用域（局部作用域）。声明在函数内部的变量，只能在函数内部使用。 块级作用域。ES6 引入的概念。块级作用域通过花括号（{}）创建，会将 let 和 count 声明的变量作用域限制在当前代码块中。var 的声明提前会无视块级作用域。 作用域是分层的，子作用域可以沿着链式的作用域链访问父作用域的变量，反之则不行。 那么什么是闭包呢？ 当函数（子作用域）存在对父作用域的引用时，为了保证函数的正常执行，这时即使父作用域执行结束关闭了，但引用的变量依然会被保留，不被回收释放，这种特殊的机制就是闭包。 闭包的一个实用作用是创建私有变量和方法。 一个例子是累加器，非闭包的话变量会被全局访问到，被重新定义或修改的话就累加功能就被破坏了，通过闭包就可以规避这个问题。 另一个例子是存储，可以通过闭包实现类似 vuex 的能力。提供特定的方法来增删改查在闭包中的引用值。 闭包的一个经典问题是：在循环中创建闭包：一个常见错误。 原因是执行上下文在运行时才确定。 继承与原型链 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 为了理解这段话，我们先看看继承是怎么产生的。 1234const name = '张三'const rename = name.replace('张三', '李四')console.log(rename)// output: 李四 上面是这段代码声明了一个 name 常量，并调用 replace()。这时问题就来了，replace() 咋来的呢？ JavaScript 是一种基于原型的语言，这段代码在执行时，name 实际上是 String 的实例： 1234const name = new String('张三') // String {'张三'}const rename = name.replace('张三', '李四')console.log(rename)// output: 李四 作为 String 的实例，name 并不是一个单纯的字符串，而是一个对象。name 的隐式属性 __proto__ 指向 String 的原型。当访问 name 的属性和方法时，会按照原型链依次向上寻找，直至访问到 null 为止。而调用 replace() 就是通过对 String 的继承形成的原型链，访问到了存在于 String 的原型的方法。 String 的原型也有自己的 __proto__，指向 Object 的原型。于是，基于这样的继承关系，完整的原型链如下： 1name -&gt; String.prototype -&gt; Object.prototype -&gt; null 同理，其他几种数据类型也一样，都是由对应的构造函数创建的实例，所以才说 JavaScript 万物皆对象。 构造函数和原型的关系是：构造函数的 prototype 属性指向原型对象，这个对象包含所有实例共享的方法和属性。原型对象的 constructor 指向构造函数本身。 构造函数和正常函数没有本质的区别，一个使用 function 正常声明的函数，用 new 操作符调用，就是构造函数。我们也可以自己创建构造函数来实现继承，代码如下： 1234567891011121314151617function Person(gender) { this.gender = gender}Person.prototype.body = 1Person.prototype.eye = 2Person.prototype.eat = function(food) { console.log('Ate:', food)}const LiHua = new Person('男') // Person {gender: '男'}LiHua.eat('apple') // Ate: apple/** * LiHua 的继承链如下： * LiHua -&gt; Person.prototype -&gt; Function.prototype -&gt; Object.prototype -&gt; null*/ 箭头函数没有原型，也就没有对应的构造函数，所以无法使用 new 操作符。 new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象，即{}； 为步骤 1 新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象； 将步骤 1 新创建的对象作为 this 的上下文； 如果该函数没有返回对象，则返回 this。 深拷贝事情循环机制（event loop）垃圾回收机制JavaScript 解释器","link":"/2022/08/20/JavaScript%E5%9F%BA%E7%A1%80/"},{"title":"Vue 3.0 入门","text":"新功能Composition API #提供了一种SFC（单文件组件）写法之外的实现方式 增加了 setup 语法和相关语法糖[实验性] teleport（传送）将组件中的 DOM 挂载到 body 或指定 DOM position: fixed，z-index 等问题 Fragments（片段）在Vue 3中，组件现已正式支持多根节点组件 Emits Component Option新的组件选项：emits，和 props 一样，通过对象的写法，可以对方法进行验证 目前没有语法提示 验证失败会在控制台抛出 [Vue warn] scoped-styles深度选择器&gt;&gt;&gt;和/deep/支持已弃用，他们仅被Vue的SFC编译器用作编译时提示以重写选择器，并在最终CSS中被删除。 ::v-deep 不推荐用作选择器 原来的选择器有各种兼容问题，CSS伪元素实际上在语义上不是选择器。与惯用CSS相比，伪元素可以接受参数更一致 深度选择器 插槽选择器：在 Vue3 中默认使子组件的样式不影响插槽的内容，为了明确地指定插槽内容，可以使用该选择器 全局选择器：在 scoped style 中声明全局样式。 12345678910111213141516&lt;style scoped&gt;/* deep selectors */::v-deep(.foo) {}/* shorthand */:deep(.foo) {}/* targeting slot content */::v-slotted(.foo) {}/* shorthand */:slotted(.foo) {}/* one-off global rule */::v-global(.foo) {}/* shorthand */:global(.foo) {}&lt;/style&gt; style-variables 【实验性】允许在 css 中使用可响应变量 例子： 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;text&quot;&gt;hello&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { color: 'red' } }}&lt;/script&gt;&lt;style vars=&quot;{ color }&quot;&gt;.text { color: var(--color);}&lt;/style&gt; 编译后： 1&lt;div style=&quot;--color:red&quot; class=&quot;text&quot;&gt;hello&lt;/div&gt; 如果同时使用了 scoped 和 vars，则所有变量都是本地变量，可以使用 global: 前缀来使用全局变量： 123456&lt;style scoped vars=&quot;{ color }&quot;&gt;h1 { color: var(--color); font-size: var(--global:fontSize);}&lt;/style&gt; 新提案：SFC style CSS variable injection (new edition) 破坏性改动移除全局 Vue为了避免全局污染，提供新的API createApp 来返回应用实例 此改动会导致： 无法通过原型链（prototype）挂载，新增 config.globalProperties 替代挂载原型链操作 插件无法自安装 可以自定义工厂函数来为所有应用共享配置 Global API Treeshaking # tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。 受影响的API： Vue.nextTick (&lt;Promise&gt;) Vue.observable（替换为Vue.reactive） Vue.version Vue.compile （仅完整版本） Vue.set （仅在兼容版本中） Vue.delete （仅在兼容版本中） 除此之外，许多内部组件/帮助器现在也以命名导出的形式导出，当你使用时才导出功能代码，例如： 123&lt;transition&gt; &lt;div v-show=&quot;ok&quot;&gt;hello&lt;/div&gt;&lt;/transition&gt; 被编译成类似于以下内容： 12345import { h, Transition, withDirectives, vShow } from 'vue'export function render() { return h(Transition, [withDirectives(h('div', 'hello'), [[vShow, this.ok]])])} 移除 filters使用 计算属性 computed 或调用函数处理 v-model 移除 v-bind 的 .sync 修饰符 移除组件的 model 选项 一个组件可以绑定多个 v-model 自定义组件上使用时，v-model 的 props 和 event 默认名称已改为： props: value -&gt; modelValue event: input -&gt; update:modelValue 杂项 key：&lt;template v-for&gt; key 应放置在&lt;template&gt;标签上 修饰符： v-on不再支持使用数字（即keyCodes）作为修饰符 v-on.native 已删除，现在组件所有事件都会在根元素添加监听 props：props default 不能访问 this 事件：$on，$off和$once被删除，不再支持事件巴士写法 过渡：v-enter 过渡类名改为 v-enter-from，v-leave 过渡类改为 v-leave-from 移除了 Functional Component，两者差别在vue3可以忽略不计 指令优先级： v-for 高于 v-if -&gt; v-if 优先级始终高于 v-for 单个属性始终覆盖 v-bind=&quot;object&quot; -&gt; 根据绑定的声明顺序决定 watch 数组时，只有数组在被替换时才会触发 handler，如果想要监听数组内部改动，需要使用 deep: true 生命周期选项 destroyed 已更名为 unmounted，beforeDestroy 更名为 beforeUnmount 底层原理响应式defineProperty -&gt; proxy Proxy: 代理是一个包含另一个对象或功能并允许您对其进行拦截的对象 只能兼容到 IE 11 参考Vue3 官方文档 Vue2 进阶指南 Vue rfcs（意见征求稿）","link":"/2020/12/10/Vue%203.0%20%E5%85%A5%E9%97%A8/"},{"title":"gitlab npm package 初体验","text":"前段时间公司私有化部署的 gitlab 更新了下，发现 gitlab 支持 npm 的包管理了。 随即打算把私服 nexus 上的 npm 包迁移一下，于是有了这篇文章。 这篇文章会以 gitlab 官网为示例逐步介绍如何在 gitlab 中发布和使用自己的 npm 包。 除 npm 以外，gitlab 还支持大多数常见的包管理器，如 Go、Maven、Ruby Gems 等。 前提条件： node &amp; npm/yarn gitlab 账号 gitlab npm 包注册表gitlab 要求注册的包必须是 scope packages，即包名称的格式必须是 @scope/package-name。 gitlab 提供两个选项来作为包的端点，项目级和实例级： 项目级：当你有很少的 npm 包并且它们不在同一个 GitLab 组中时使用。该软件包的命名约定没有在这个级别执行。相反，您应该为您的包使用范围。使用范围时，注册表 URL仅针对该范围更新。在项目级别注册包时，您可以使用/附加您自己的唯一范围到您的包名称。如果需要，可以公开在项目级别注册的包。 实例级：当您在不同的 GitLab 组或它们自己的命名空间中有许多 npm 包时使用。请务必遵守包命名约定。 这是谷歌翻译的原文，不太好理解，后面会解释两种端点的差异。 这块详情可见官方文档。 gitlab 设置先在 gitlab 中创建一个空白仓库 hex2rgb 作为我们待会项目提交的仓库。 创建好后记录一下存储库的 git URL 和 project ID, 后面会用到它们。 初始化项目接下来写一个简单的 commonJS 模块作为待会要发布的 npm 包。 创建并进入文件夹。 1mkdir hex2rgb &amp;&amp; cd hex2rgb 项目初始化，包名称需要注意使用 scope 包模式（@username/projectname），scope 为自己的用户名，其他默认。 1234yarn init# yarn init v1.22.4# question name (hex2rgb): @mubeisama/hex2rgb 初始化的 package.json 内容如下： 1234567{ &quot;name&quot;: &quot;@mubeisama/hex2rgb&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;} 添加 /index.js 文件。 123456789101112/** * @param {string} hex example: #000000 * @return {string} */function hex2rgb(hex) { const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex) if (!result) return null const [, r, g, b] = result return `rbg(${parseInt(r, 16)}, ${parseInt(g, 16)}, ${parseInt(b, 16)})`}module.exports = hex2rgb 写好了，准备发布。 发布包gitlab 提供两种发布方法： 命令行，npm publish 或 yarn publish，这种方式需要手动添加个人的 gitlab Access Token 到配置中 CI/CD，触发后自动发布，不需要手动配置 Access Token CI/CD 方式添加 /.npmrc 文件。 1234567891011# Set URL for your scope packages.# @&lt;your_scope&gt;:registry=https://gitlab.com/api/v4/npm/@mubeisama:registry=https://gitlab.com/api/v4/npm/# Add the token for the scope packages URL. This will allow you to download//gitlab.com/api/v4/packages/npm/:_authToken=${CI_JOB_TOKEN}# Add token for uploading to the registry. Replace &lt;your_project_id&gt;# //gitlab.com/api/v4/projects/&lt;your_project_id&gt;/packages/npm/:_authToken=${CI_JOB_TOKEN}//gitlab.com/api/v4/projects/31255575/packages/npm/:_authToken=${CI_JOB_TOKEN} 内容为鉴权配置，注意替换 scope 名称 和 project_id。 此处的 CI_JOB_TOKEN 是 CI/CD 的默认环境变量，可以代替个人 Token。 再添加 /.gitlab-ci.yml 文件。 1234567891011image: node:14.18.1-slimstages: - buildbuild: stage: build script: - npm publish only: - main 更新 package.json，增加 publishConfig。 12345678{ &quot;name&quot;: &quot;@mubeisama/hex2rgb&quot;, ... &quot;publishConfig&quot;: { // 替换为自己的 scope &quot;@mubeisama:registry&quot;: &quot;https://gitlab.com/api/v4/projects/31255575/packages/npm/&quot; }} 配置完成。接下来提交到 main 分支就会触发 CI/CD 了。 123456# 替换为自己的仓库地址git init --initial-branch=maingit remote add origin https://gitlab.com/MuBeiSAMA/hex2rgb.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin main 如果 git init --initial-branch=main 报错的话，升级 git 到最新版即可解决。 配置没错的话，CI/CD 的 pipeline 里会有条记录。 跑完后包注册表里就能看到打好的包了。 命令行方式在 gitlab 首页点右上角的头像，展开的菜单里点 preferences 进入偏好设置。 在 Access Tokens 面板创建 Token，权限按需勾选，创建好后的 Token 只会在顶部出现一次，记录下来。 回到项目里，修改 .npmrc，将 CI_JOB_TOKEN 替换为自己的 Token： .npmrc12345@mubeisama:registry=https://gitlab.com/api/v4/npm///gitlab.com/api/v4/packages/npm/:_authToken=&lt;your_token&gt;//gitlab.com/api/v4/projects/31255575/packages/npm/:_authToken=&lt;your_token&gt; 修改版本号后执行发布命令即可。 1npm publish 记录里会标注出是手动发布。 端点的解释点击发布的 npm 包进入详情，其中的 Registry setup 就是本文开头提到的包的端点。 项目级和实例级的区别就在于安装地址不同： 项目级 下载地址必须是带上项目 ID 的地址 实例级 gitlab 的全局地址，更接近我们平时使用的 npm 注册表 那是所有发布的包都支持项目级和实例级端点吗？不是。 前文中提到需要使用自己的用户名（根命名空间）作为 scope，这其实不是必须的，你可以使用任意字符作为 scope，任意 scope 的话（非根命名空间），这个包在安装时就只支持项目级端点，因为不符合包命名约定，使用实例级安装地址会报 404 error。 而在发布包时，必须是项目级端点，也就是必须提供一个仓库，作为发布地址。 使用包全局安装使用项目级 npm 端点 npm 配置： 12345678# Set URL for your scoped packages.# For example package with name `@foo/bar` will use this URL for downloadnpm config set @foo:registry https://gitlab.example.com/api/v4/projects/&lt;your_project_id&gt;/packages/npm/# Add the token for the scoped packages URL. Replace &lt;your_project_id&gt;# with the project where your package is located.npm config set -- '//gitlab.example.com/api/v4/projects/&lt;your_project_id&gt;/packages/npm/:_authToken' &quot;&lt;your_token&gt;&quot; 使用实例级 npm 端点 npm 配置： 1234567# Set URL for your scoped packages.# For example package with name `@foo/bar` will use this URL for downloadnpm config set @foo:registry https://gitlab.example.com/api/v4/packages/npm/# Add the token for the scoped packages URL. This will allow you to download# `@foo/` packages from private projects.npm config set -- '//gitlab.example.com/api/v4/packages/npm/:_authToken' &quot;&lt;your_token&gt;&quot; 配置好后直接安装即可。想更详细了解可见官方文档。 工作区安装随处找个地创建一个新文件夹。 1mkdir ues-hex2rgb &amp;&amp; cd ues-hex2rgb 初始化项目，全默认。 1npm init 执行上图 Registry setup 的命令。 1echo @mubeisama:registry=https://gitlab.com/api/v4/packages/npm/ &gt;&gt; .npmrc 如果是公开的仓库，执行安装命令即可。 1npm i @mubeisama/hex2rgb 如果是私有仓库，还需要编辑 .npmrc，添加鉴权配置，再执行安装命令。 .npmrc123@mubeisama:registry=https://gitlab.com/api/v4/packages/npm/# add auth token//gitlab.com/api/v4/packages/npm/:_authToken=&lt;your_token&gt; 添加 /app.js。 12345const hex2rgb = require('@mubeisama/hex2rgb')const rgb = hex2rgb('#dd2b0e')console.log('rbg：', rgb) 执行 12node app.js# rbg： rbg(221, 43, 14) 打印正常，收工。 参考链接官方文档：https://docs.gitlab.com/ee/user/packages/npm_registry/ 项目地址：https://gitlab.com/MuBeiSAMA/hex2rgb","link":"/2021/11/12/gitlab%20npm%20package%20%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"【国际化】自动提取语言配置文件及使用","text":"简单介绍i18next-scannernode插件，扫描您的代码，提取翻译键/值，然后将它们合并到i18n资源文件中。 vue-i18nVue.js 的国际化插件，提供本地化相关功能，集成在vue当中。 i18next-scanner 使用安装1yarn add i18next-scanner -D 添加到 package.json scripts123&quot;scripts&quot;: { &quot;scan&quot;: &quot;i18next-scanner&quot;}, i18next-scanner 指令会寻找当前目录下的 i18next-scanner.config.js 文件，缺少就会报错。 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546const fs = require('fs')const { crc32 } = require('crc')module.exports = { input: [ 'src/**/*.{js,vue}', // Use ! to filter out files or directories '!src/config/i18n/**', '!**/node_modules/**' ], output: './', // 输出目录 options: { debug: true, func: false, trans: false, lngs: ['cn', 'en'], defaultLng: 'cn', resource: { loadPath: './src/config/i18n/{{lng}}/{{ns}}.json', // 输入路径 savePath: './src/config/i18n/{{lng}}/{{ns}}.json', // 输出路径 jsonIndent: 2, lineEnding: '\\n' }, removeUnusedKeys: false, // 移除未使用的 key nsSeparator: false, // namespace separator keySeparator: false, // key separator interpolation: { prefix: '{{', suffix: '}}' } }, transform: function customTransform(file, enc, done) { // 自己通过该函数来加工key或value 'use strict' const parser = this.parser const content = fs.readFileSync(file.path, enc) /** * @param {list} array 指定扫描的标识 */ parser.parseFuncFromString(content, { list: ['lang'] }, (key, options) =&gt; { options.defaultValue = key // 将传入的文字转成配置的 key，不一定非用 crc，别的也行，如果内容不会影响 json 格式，不用也行 let hashKey = `k${crc32(key).toString(16)}` parser.set(hashKey, options) }) done() }} 配置文件添加之后， i18next-scanner 就能使扫描文字了，运行： 1yarn scan 会根据配置中的语言空间导出到对应的文件夹，导出的文件长这样： 12345678{ &quot;kee8ae330&quot;: &quot;查询&quot;, &quot;k50d471b2&quot;: &quot;重置&quot;, &quot;kebceb256&quot;: &quot;修改中...&quot;, &quot;k2d46b71b&quot;: &quot;删除中...&quot;, &quot;kb135e9bd&quot;: &quot;下载中...&quot;, &quot;ked2baf28&quot;: &quot;加载中...&quot;} 通过以上方式，实现中文作为代码中的多语言的key，而且用中文作为key不会导致索引语言包导致的性能或索取不准确的问题，因为中文会先转化为crc32的key然后对象的再去索引同样以crc32为key的语言包，这样可以实现中文作为代码中的key，却实际上还是以准备的hashkey来索引语言包。 这样就不需要自己写配置文件，使用的时候再一个个去对了，直接在需要使用多语言的地方加上扫描标识方法就能本地化。 i18n 使用i18n index.js通过 lang 方法，将文字再转为 key，lang() 同时也是 i18next-scanner 扫描标识。 1234567891011121314151617181920212223242526272829import Vue from 'vue'import VueI18n from 'vue-i18n'import en from './en/translation.json'import cn from './cn/translation.json'import crc32 from 'crc/crc32'/* 语言包导入 */Vue.use(VueI18n)const i18n = new VueI18n({ locale: 'cn', // set locale messages: { cn, en }})export function lang(key) { let hashKey = `k${crc32(key).toString(16)}` let words = i18n.t(hashKey) if (words === hashKey) { words = key console.log(key, '-没翻译') } return words};export default i18n main.js123456import Vue from 'vue'import i18n, { lang } from './config/i18n/index.js'Vue.prototype.$lang = langnew Vue({ ..., i18n }) 代码中使用html 1&lt;button&gt;{{ $lang('查询') }}&lt;/button&gt; js 1const hide = this.$message.loading(this.$lang('修改中...'), 0) 至此就大功告成了 拓展微前端中动态切换语言主项目中： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;lang&quot; @click=&quot;switchLang&quot;&gt;{{ langConfig[lang] }}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { langConfig: { 'cn': 'English', 'en': '中文' }, lang: 'cn' } }, methods: { switchLang() { this.lang = this.lang === 'cn' ? 'en' : 'cn' this.$root.storeModule.commit('setLang', this.lang) // i18n 的实例方法 this.$i18n.locale = this.lang }, }};&lt;/script&gt; 子项目 App.vue 中： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;a-locale-provider :locale=&quot;locale&quot;&gt; &lt;div id=&quot;content&quot;&gt; &lt;router-view/&gt; &lt;/div&gt; &lt;/a-locale-provider&gt;&lt;/template&gt;&lt;script&gt;import zhCN from 'ant-design-vue/lib/locale-provider/zh_CN'import enUS from 'ant-design-vue/lib/locale-provider/en_US'export default { data () { return { locale: zhCN } }, watch: { '$root.storeModule.state.lang'(lang) { console.log('call $root.storeModule.state.lang') this.$i18n.locale = lang this.locale = lang === 'cn' ? zhCN : enUS } }}&lt;/script&gt; 总结对比传统 i18n 做法的优点： 省时省力，不再需要创建配置文件后挨个匹配路径 可读性更好，本地化的位置直接就是中文汉字，不会因为丢失文字而不知其意 效率高、成本低、开发无感，只需要把本地化的地方加上标识，扫描后的文件翻译即可 对比传统 i18n 做法的缺点： 灵活性稍微降低，使用中文作为配置的 key，会导致一样的中文都是一样的 key，那么翻译也会一样。当出现位置不同，中文相同，而翻译想要更明确时，会比较麻烦 配置文件较大，一种语言空间的配置都在一个 json 中，没法同种语言多个配置按需加载 另外，i18next-scanner 还有一个很大的缺陷，它只能通过 function 和 attr 来标识提取的内容 参考链接i18next-scanner https://github.com/i18next/i18next-scanner vue-i18n https://github.com/kazupon/vue-i18n zcmzks vue或react多语言自动化实现扫描代码的多语言-i18next-scanner https://www.cnblogs.com/jocongmin/articles/12716786.html","link":"/2020/04/22/%E3%80%90%E5%A4%9A%E8%AF%AD%E8%A8%80%E3%80%91%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"title":"多平台微信统一登陆","text":"对各平台登陆和 unionid 获取稍做介绍。时效，权限等问题可在参考链接中了解详情 unionid 机制说明 用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的unionid是唯一的。 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。 登陆流程 &amp; unionid 获取 微信登陆场景大致分为 app、公众号、小程序和 web pc 端。在流程上除了小程序比较特殊外，其他基本一致。 小程序登陆 &amp; 敏感数据获取 小程序端调用 wx.login() 获取 临时登录凭证code（有效期五分钟） ，并回传到服务端。 服务端调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。 小程序端带上登陆态参数 {withCredentials: true} 调用 wx.getUserInfo() 接口，获取解密时所需的 加密算法的初始向量 iv 和 包括敏感数据在内的完整用户信息的 加密数据 encryptedData，并回传到服务端。需要注意的是，要求此前调用过 wx.login 且登陆态尚未过期，返回的数据才会包含 encryptedData, iv 等信息。 加密数据解密算法服务端对 加密数据（encryptedData） 进行对称解密，即可获取用户的 openId 和 unionId。解密算法如下： 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。 对称解密的目标密文为 Base64_Decode(encryptedData)。 对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。 对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。 微信官方提供了多种编程语言的示例代码（点击下载）。每种语言类型的接口名字均一致。调用方式可以参照示例。 另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印(watermark) web pc 端微信登录基于OAuth2.0协议标准构建的微信OAuth2.0授权登录系统。 需要提前在 微信开放平台 注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的 AppID 和 AppSecret，申请微信登录且通过审核后，可开始接入流程。 获取 code方式一 跳转到指定链接获取授权访问 https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 请求 code。 参数来源于开放平台中对网站应用。 方式二 页面内微信登陆二维码 在页面中先引入如下JS文件（支持https）： 1http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js 在需要使用微信登录的地方实例以下JS对象： 12345678910var obj = new WxLogin({ self_redirect: true, // true：手机点击确认登录后可以在 iframe 内跳转到 redirect_uri，false：手机点击确认登录后可以在 top window 跳转到 redirect_uri。默认为 false。 id: &quot;login_container&quot;, // 【必填】 第三方页面显示二维码的容器id appid: &quot;&quot;, // 【必填】应用唯一标识，在微信开放平台提交应用审核通过后获得 scope: &quot;&quot;, // 【必填】应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可 redirect_uri: &quot;&quot;, // 【必填】重定向地址，需要进行UrlEncode state: &quot;&quot;, // 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验 style: &quot;&quot;, // 提供&quot;black&quot;、&quot;white&quot;可选，默认为黑色文字描述。 href: &quot;&quot; // 自定义样式链接，第三方可根据实际需求覆盖默认样式。}); 以上两种方式，用户允许授权后，都将重定向到redirect_uri的网址上，并且带上code和state参数 redirect_uri?code=CODE&amp;state=STATE access_token &amp; unionid通过 code 获取 access_token 1https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 正确的返中即包含 unionid： 12345678{&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200,&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,&quot;openid&quot;:&quot;OPENID&quot;,&quot;scope&quot;:&quot;SCOPE&quot;,&quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;} 拓展 调用微信接口access_token 是调用授权关系接口的调用凭证，微信提供了许多智能接口，凭借 access_token 即可调用 获取用户信息12http请求方式: GEThttps://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID 微信智慧接口-语义理解接口1234567891011http请求方式: POST（请使用https协议）https://api.weixin.qq.com/semantic/semproxy/search?access_token=YOUR_ACCESS_TOKENPOST数据格式：JSONPOST数据例子：{&quot;query&quot;:&quot;查一下明天从北京到上海的南航机票&quot;,&quot;city&quot;:&quot;北京&quot;,&quot;category&quot;: &quot;flight,hotel&quot;,&quot;appid&quot;:&quot;wxaaaaaaaaaaaaaaaa&quot;,&quot;uid&quot;:&quot;123456&quot;} 详细可见：微信智能接口 参考链接微信官方文档 - 小程序 UnionID 机制说明 https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html 微信官方文档 - 小程序 开放数据校验与解密 https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html 微信开放平台 - 网站应用接入 https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html","link":"/2020/03/09/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"},{"title":"微信小程序局域网通信","text":"基于 mDNS 协议实现 http 和 socket 通信 Windows 上未找到可用的 mDNS 服务发现工具，Linux 上可使用 avahi，MacOS 上可使用 Bonjour。 本项目使用 Linux 作为通信终端。 项目地址：https://github.com/MuBeiSAMA/lan-communication-mp 技术栈 服务发现 avahi server express socket.io client 小程序 mDNS 系列 API weapp.socket.io 服务端（Linux）安装 avahi1sudo apt-get install avahi-utils 注册服务1avahi-publish-service -s &quot;yourServiceName&quot; _http._tcp 1111 参数分别为：服务名称，服务类型，端口号。 运行后即可在局域网中被发现。 运行 servernodejs，npm 或 yarn 为必备环境，不做赘述。 先进入 server 文件夹 1cd server 安装依赖 12345# 使用 yarnyarn# 或使用 npmnpm i 运行脚本 1node index.js 终端打印 listening on *:1111 即表示运行成功，将持续监听 1111 端口，与注册服务时暴露的端口号一致。 脚本基于 express 和 socket.io 分别提供了 http 和 socket 的通信能力。 客户端（小程序）小程序局域网通信详情可见 局域网通信。 服务发现12345678910111213/** * 开始搜索局域网下的 mDNS 服务。搜索的结果会通过 wx.onLocalService* 事件返回。 * @param { object } object.serviceType 必填项 要搜索的服务类型 */wx.startLocalServiceDiscovery({ serviceType: '_http._tcp.'})/** * 监听 mDNS 服务发现的事件 * @param {function} callback 发现了服务的回调，参数为单个服务数据 */wx.onLocalServiceFound(function callback) 服务数据onLocalServiceFound 方法回调中的数据如图： 根据数据中的 ip 和 port 信息，即可进行 http 和 socket 通信。 Tips 一些 OS 可能不支持 mDNS 服务发现，这时可使用微信开发工具的真机调试功能进行调试。","link":"/2019/09/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/"},{"title":"记录一次手机 ROOT 的详细过程","text":"我手持的是小米 Redmi K20 Pro, MIUI 12.5，骁龙 855 芯片，用了两年多依旧坚挺。 ROOT 的起因是最近在玩一款单机手游，实在太肝了受不了，想开修改器和加速之类的降低一点难度。当然 ROOT 之后不仅仅是开个修改器，还有很多能力。 小米 ROOT 的方式很多，我大概举例一下： 申请官方内测资格，最简单安全的方式。小米社区直接申请，申请成功后系统可以转为开发版，社区有详细步骤，开发版自带 ROOT 权限。缺点就是需要积分，申请内测资格需要 300 点内测分，还需要答题。我只有 100 多分，太麻烦了，放弃。 Magisk 补 BOOT，应该是目前最主流的 ROOT 方式。不影响当前系统，稳定版一样可以获取 ROOT 权限，仅依赖 Magisk 就够了，重启也不影响，缺点是每次系统更新都需要重新补 BOOT。 刷第三方 Recovery（简称 rec）橙狐再补 BOOT。还是依靠 Magisk 补 BOOT，再通过橙狐刷入，橙狐自带 xiaomi ota，后续系统升级可以通过它来完成，ROOT 权限就能一直存在了。 我采用的是第三种方式，看起来很多术语很复杂，实操起来几分钟就能搞定。 解 BL 锁这应该是目前所有手机 ROOT 的第一步了，小米可以直接访问 官方解锁地址，按步骤操作，需要手机登陆小米账号满 7 天。 需要注意解锁时数据将被清空，一定要提前备份。小米换机可以 100% 备份所有数据。手机备份打的包只有应用数据，不包含照片和主题，需要额外备份。 后面的操作解了 BL 锁才能继续，不会再清空数据了，不过以防万一还是留一份备份比较好。 开始 ROOT准备工作需要用到的物料： 联网的 PC 一台 数据线 PC 上需要准备的软件： 橙狐 的 recovery.img 文件 Magisk 的安装包 当前手机系统的 ROM 文件 【可选】搞机助手 从橙狐的包中提取 recovery.img橙狐的包可以访问官网，找到自己的手机型号，点下载再点弹窗里的国家节点即可下载。 下载好后解压压缩包，将里面的 recovery.img 文件提取到自己找得到的地方备用。 Magisk的安装包GitHub 开源软件，访问 Release 页面下载最新版就好。 当前手机系统的 ROM 包访问 https://xiaomirom.com/ 搜索自己的手机型号，我是 K20 Pro，国外这款手机叫 9T Pro。 点进去找到和自己一样的 MIUI 版本的包，我的是 V12.5.6.0.RFKCNXM。 下载完成后解压压缩包，将里面的 boot.img 文件提取到自己找得到的地方备用。 发送到手机数据线连接手机，打开 USB 调试。没有 USB 调试就先在 设置-&gt;我的设备-&gt;全部参数 点击 MIUI 版本七八次，打开开发者模式，再搜 USB 调试就有了。 通过数据线将准备好的 Magisk 安装包、recovery.img 和 boot.img 传到手机存储下。 Magisk 补 BOOT在手机上找到发来的 Magisk 安装包，安装。安装好后界面如下： 点击 Magisk 卡片的安装按钮，进入安装详情页。 选项栏什么都不用选直接下一步，方式选中选择并修补一个文件，然后选择从 PC 接收的 boot.img 文件开始修补。 修补成功后会在 download 文件夹生成 magisk_patched_xxxxxx.img 文件。记住这个文件名和的位置，之后会用到。 刷入橙狐保持 PC 和手机的数据线连接，手机关机后开机键+音量下键，进入 fastboot 模式。 如果电脑上准备好了搞机助手，就在引导模式-&gt;刷入 REC-&gt;选择 Recovery选中准备好的橙狐 的 recovery.img 文件，点击刷入。 没有搞机助手的话，可以参考橙狐官方 wiki，电脑安装 adb，命令行直接输入命令手动刷入： 1fastboot flash recovery recovery.img 刷入后手机会自动进入 橙狐 rec，没有自动进入的话也可以在关机后按开机键+音量上键进入。 橙狐的recovery有解密功能启动可能较慢 启动后输入锁屏密码 等待解密 否则无法加载sdcard 输入锁屏密码成功后, 橙狐 的首页就是一个文件管理器，找到从 PC 接收的 recovery.img，选中，目标分区选 Recovery。 成功后先不重启，继续找到之前 Magisk 补好的 magisk_patched_xxxxxx.img 文件，刷入到 Boot 分区，完成后重启。 开机后就有 ROOT 权限了。 拓展之前说 ROOT 后不仅仅是开个修改器。 Magisk 更新导致 zygisk 和 Riru 不兼容，Lsposed 也没法用了。听说有个 zygisk-lsposed 的兼容版，github 也没找到，更新之后再补充。 参考https://www.bilibili.com/read/cv13745586https://github.com/LSPosed/LSPosedhttps://github.com/topjohnwu/Magisk","link":"/2022/02/25/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%BAROOT%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/"},{"title":"钉钉配置化流程调研","text":"配置化流程，实际上就是根据配置好的数据，动态创建表单。 流程上大致可以分为： 图形化的表单数据配置和创建 表单数据存储和展示 通过数据创建表单 需要实现两个主要功能： 图形化表单编辑器 表单生成器 思路钉钉有审核流程的设计，如果不考虑审核流程的话，和 AIoT 的自定义字段功能相差不多。 图形化表单编辑器这块实现起来大致分为三个部分： 控件预定义 控件拖拽 控件编辑 控件预定义对于常用的输入控件的具象化。 配置型表单首要解决的问题就是控件差异性和控件数据处理。 对于常用的控件，例如定位、身份证输入框和部门选择之类的，可以先定义好样式和数据的配置，供配置时直接选用。 另外，对于操作复杂、关联性强的控件，可以预定义一套配置，作为套件。 控件拖拽图形化配置关键功能，有已实现的成熟开源库，效果如下： 控件编辑对于控件各种配置的预置。 简单点的有 placeholder、label 之类的设置，复杂点的有级联选择器的数据、日期控件的 format 等。 也可以在这一步预置控件的值。 表单生成器选定 UI 框架，再拿到设定好的配置，就可以生成表单了，这一步最简单，不做赘述。 复杂的地方在于配置的定义和控件字段。 配置定义：比较好理解，就是对于控件的一些数据定义下字段，比如选择器的 options 列表，默认选择的项、标题、宽度之类的。控件种类越多，需要定义的字段也就越多。 控件字段：因为可能存在相同类型的重复控件，所以控件的字段名要用一个不重复的代号表示。这样在往数据库里存的时候就会有点小问题。一是不知道这个字段内容的具体意义，二是字段和数据库字段肯定对不上，只能转为 string json 存在记录某个字段里。只有配合表单配置这个数据才有意义。 实现这样一个项目复杂度不低，好在已经有不少开源库实现了类似功能。 form-generator Element UI表单设计及代码生成器 可以满足配置化表单的基本需求。 不过不支持 antd，没有审核流程。 approvalFlow 基于form-generator，仿钉钉审批流程创建（表单创建/流程节点可视化配置/必填条件及校验） 图形化表单编辑器和表单生成器都有，完全符合需求，MIT 开源协议，基于 form-generator，同样不支持 antd，可以基于这个项目做些个性化开发。","link":"/2020/07/30/%E9%92%89%E9%92%89%E9%85%8D%E7%BD%AE%E5%8C%96%E6%B5%81%E7%A8%8B%E8%B0%83%E7%A0%94/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","link":"/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"复习","slug":"复习","link":"/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"vue-next","slug":"vue-next","link":"/tags/vue-next/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"gitlab","slug":"gitlab","link":"/tags/gitlab/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"i18n","slug":"i18n","link":"/tags/i18n/"},{"name":"国际化","slug":"国际化","link":"/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"i18next-scanner","slug":"i18next-scanner","link":"/tags/i18next-scanner/"},{"name":"vue-i18n","slug":"vue-i18n","link":"/tags/vue-i18n/"},{"name":"微信","slug":"微信","link":"/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"auth2","slug":"auth2","link":"/tags/auth2/"},{"name":"微信登陆","slug":"微信登陆","link":"/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E9%99%86/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"局域网通信","slug":"局域网通信","link":"/tags/%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/"},{"name":"小米&#x2F;MIUI","slug":"小米-MIUI","link":"/tags/%E5%B0%8F%E7%B1%B3-MIUI/"},{"name":"ROOT","slug":"ROOT","link":"/tags/ROOT/"},{"name":"Magisk","slug":"Magisk","link":"/tags/Magisk/"},{"name":"橙狐&#x2F;OrangeFox","slug":"橙狐-OrangeFox","link":"/tags/%E6%A9%99%E7%8B%90-OrangeFox/"},{"name":"安卓&#x2F;Android","slug":"安卓-Android","link":"/tags/%E5%AE%89%E5%8D%93-Android/"},{"name":"钉钉","slug":"钉钉","link":"/tags/%E9%92%89%E9%92%89/"},{"name":"表单配置化","slug":"表单配置化","link":"/tags/%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%E5%8C%96/"},{"name":"低代码","slug":"低代码","link":"/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"}],"categories":[{"name":"前端知识体系","slug":"前端知识体系","link":"/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"技术方案","slug":"技术方案","link":"/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"},{"name":"搞机","slug":"搞机","link":"/categories/%E6%90%9E%E6%9C%BA/"}],"pages":[{"title":"关于我","text":"前端开发工程师 @SmartAHC","link":"/about/index.html"}]}